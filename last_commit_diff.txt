commit c9007c1e44e0a98c3399cae96ce4a486fbd185cb
Author: Manus <manus@example.com>
Date:   Mon Jul 7 07:20:09 2025 -0400

    Revert "Revert "wip""
    
    This reverts commit 2ac4b9a899ff082e19865a483a5c13aad6f52828.

diff --git a/eslint.config.mjs b/eslint.config.mjs
index 11a1e05..647b45d 100644
--- a/eslint.config.mjs
+++ b/eslint.config.mjs
@@ -19,7 +19,7 @@ export default tseslint.config(
       },
       sourceType: 'commonjs',
       parserOptions: {
-        projectService: true,
+        project: './tsconfig.json', // ✅ ESSENCIAL
         tsconfigRootDir: import.meta.dirname,
       },
     },
diff --git a/estrutura.txt b/estrutura.txt
deleted file mode 100644
index 8af4c4e..0000000
Binary files a/estrutura.txt and /dev/null differ
diff --git a/extrutura.txt b/extrutura.txt
deleted file mode 100644
index dd7f943..0000000
Binary files a/extrutura.txt and /dev/null differ
diff --git a/package-lock.json b/package-lock.json
index e5fea3b..84c8fa6 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -12,6 +12,7 @@
         "@nestjs/common": "^11.0.1",
         "@nestjs/core": "^11.1.3",
         "@nestjs/jwt": "^11.0.0",
+        "@nestjs/mapped-types": "^2.1.0",
         "@nestjs/passport": "^11.0.5",
         "@nestjs/platform-express": "^11.0.1",
         "@prisma/client": "^6.10.1",
@@ -21,18 +22,23 @@
         "@types/passport-jwt": "^4.0.1",
         "@types/passport-local": "^1.0.38",
         "bcryptjs": "^3.0.2",
+        "class-transformer": "^0.5.1",
+        "class-validator": "^0.14.2",
         "jsonwebtoken": "^9.0.2",
+        "nodemailer": "^7.0.4",
         "passport": "^0.7.0",
         "passport-jwt": "^4.0.1",
         "passport-local": "^1.0.0",
         "prisma": "^6.10.1",
         "reflect-metadata": "^0.2.2",
+        "resend": "^4.6.0",
         "rxjs": "^7.8.1",
         "zod": "^3.25.67"
       },
       "devDependencies": {
         "@eslint/eslintrc": "^3.2.0",
         "@eslint/js": "^9.18.0",
+        "@golevelup/nestjs-testing": "^0.1.2",
         "@nestjs/cli": "^11.0.0",
         "@nestjs/schematics": "^11.0.0",
         "@nestjs/testing": "^11.0.1",
@@ -47,6 +53,7 @@
         "eslint-plugin-prettier": "^5.2.2",
         "globals": "^16.0.0",
         "jest": "^29.7.0",
+        "jest-mock-extended": "^4.0.0",
         "prettier": "^3.4.2",
         "source-map-support": "^0.5.21",
         "supertest": "^7.0.0",
@@ -934,6 +941,14 @@
         "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
       }
     },
+    "node_modules/@golevelup/nestjs-testing": {
+      "version": "0.1.2",
+      "resolved": "https://registry.npmjs.org/@golevelup/nestjs-testing/-/nestjs-testing-0.1.2.tgz",
+      "integrity": "sha512-7TOpI6E86GBE93DJoCqavOfycAMPjnZDfcpdBrm/aWUoR/oDxHjhTr1R8NGVY4+iHY5wDwEXG7mcDkDEWQznfQ==",
+      "deprecated": "Package no longer supported. Contact Support at https://www.npmjs.com/support for more info.",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@humanfs/core": {
       "version": "0.19.1",
       "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
@@ -2579,6 +2594,26 @@
         "@types/node": "*"
       }
     },
+    "node_modules/@nestjs/mapped-types": {
+      "version": "2.1.0",
+      "resolved": "https://registry.npmjs.org/@nestjs/mapped-types/-/mapped-types-2.1.0.tgz",
+      "integrity": "sha512-W+n+rM69XsFdwORF11UqJahn4J3xi4g/ZEOlJNL6KoW5ygWSmBB2p0S2BZ4FQeS/NDH72e6xIcu35SfJnE8bXw==",
+      "license": "MIT",
+      "peerDependencies": {
+        "@nestjs/common": "^10.0.0 || ^11.0.0",
+        "class-transformer": "^0.4.0 || ^0.5.0",
+        "class-validator": "^0.13.0 || ^0.14.0",
+        "reflect-metadata": "^0.1.12 || ^0.2.0"
+      },
+      "peerDependenciesMeta": {
+        "class-transformer": {
+          "optional": true
+        },
+        "class-validator": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/@nestjs/passport": {
       "version": "11.0.5",
       "resolved": "https://registry.npmjs.org/@nestjs/passport/-/passport-11.0.5.tgz",
@@ -2902,6 +2937,24 @@
         "@prisma/debug": "6.10.1"
       }
     },
+    "node_modules/@react-email/render": {
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/@react-email/render/-/render-1.1.2.tgz",
+      "integrity": "sha512-RnRehYN3v9gVlNMehHPHhyp2RQo7+pSkHDtXPvg3s0GbzM9SQMW4Qrf8GRNvtpLC4gsI+Wt0VatNRUFqjvevbw==",
+      "license": "MIT",
+      "dependencies": {
+        "html-to-text": "^9.0.5",
+        "prettier": "^3.5.3",
+        "react-promise-suspense": "^0.3.4"
+      },
+      "engines": {
+        "node": ">=18.0.0"
+      },
+      "peerDependencies": {
+        "react": "^18.0 || ^19.0 || ^19.0.0-rc",
+        "react-dom": "^18.0 || ^19.0 || ^19.0.0-rc"
+      }
+    },
     "node_modules/@sec-ant/readable-stream": {
       "version": "0.4.1",
       "resolved": "https://registry.npmjs.org/@sec-ant/readable-stream/-/readable-stream-0.4.1.tgz",
@@ -2909,6 +2962,19 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/@selderee/plugin-htmlparser2": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/@selderee/plugin-htmlparser2/-/plugin-htmlparser2-0.11.0.tgz",
+      "integrity": "sha512-P33hHGdldxGabLFjPPpaTxVolMrzrcegejx+0GxjrIb9Zv48D8yAIA/QTDR2dFl7Uz7urX8aX6+5bCZslr+gWQ==",
+      "license": "MIT",
+      "dependencies": {
+        "domhandler": "^5.0.3",
+        "selderee": "^0.11.0"
+      },
+      "funding": {
+        "url": "https://ko-fi.com/killymxi"
+      }
+    },
     "node_modules/@sinclair/typebox": {
       "version": "0.27.8",
       "resolved": "https://registry.npmjs.org/@sinclair/typebox/-/typebox-0.27.8.tgz",
@@ -3650,6 +3716,12 @@
         "@types/superagent": "^8.1.0"
       }
     },
+    "node_modules/@types/validator": {
+      "version": "13.15.2",
+      "resolved": "https://registry.npmjs.org/@types/validator/-/validator-13.15.2.tgz",
+      "integrity": "sha512-y7pa/oEJJ4iGYBxOpfAKn5b9+xuihvzDVnC/OSvlVnGxVg0pOqmjiMafiJ1KVNQEaPZf9HsEp5icEwGg8uIe5Q==",
+      "license": "MIT"
+    },
     "node_modules/@types/yargs": {
       "version": "17.0.33",
       "resolved": "https://registry.npmjs.org/@types/yargs/-/yargs-17.0.33.tgz",
@@ -5512,6 +5584,23 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/class-transformer": {
+      "version": "0.5.1",
+      "resolved": "https://registry.npmjs.org/class-transformer/-/class-transformer-0.5.1.tgz",
+      "integrity": "sha512-SQa1Ws6hUbfC98vKGxZH3KFY0Y1lm5Zm0SY8XX9zbK7FJCyVEac3ATW0RIpwzW+oOfmHE5PMPufDG9hCfoEOMw==",
+      "license": "MIT"
+    },
+    "node_modules/class-validator": {
+      "version": "0.14.2",
+      "resolved": "https://registry.npmjs.org/class-validator/-/class-validator-0.14.2.tgz",
+      "integrity": "sha512-3kMVRF2io8N8pY1IFIXlho9r8IPUUIfHe2hYVtiebvAzU2XeQFXTv+XI4WX+TnXmtwXMDcjngcpkiPM0O9PvLw==",
+      "license": "MIT",
+      "dependencies": {
+        "@types/validator": "^13.11.8",
+        "libphonenumber-js": "^1.11.1",
+        "validator": "^13.9.0"
+      }
+    },
     "node_modules/cli-cursor": {
       "version": "3.1.0",
       "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-3.1.0.tgz",
@@ -5966,7 +6055,6 @@
       "version": "4.3.1",
       "resolved": "https://registry.npmjs.org/deepmerge/-/deepmerge-4.3.1.tgz",
       "integrity": "sha512-3sUqbMEc77XqpdNO7FRyRog+eW3ph+GYCbj+rK+uYyRMuwsVy0rMiVtPn+QJlKFvWP/1PYpapqYn0Me2knFn+A==",
-      "dev": true,
       "license": "MIT",
       "engines": {
         "node": ">=0.10.0"
@@ -6055,6 +6143,61 @@
         "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
       }
     },
+    "node_modules/dom-serializer": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/dom-serializer/-/dom-serializer-2.0.0.tgz",
+      "integrity": "sha512-wIkAryiqt/nV5EQKqQpo3SToSOV9J0DnbJqwK7Wv/Trc92zIAYZ4FlMu+JPFW1DfGFt81ZTCGgDEabffXeLyJg==",
+      "license": "MIT",
+      "dependencies": {
+        "domelementtype": "^2.3.0",
+        "domhandler": "^5.0.2",
+        "entities": "^4.2.0"
+      },
+      "funding": {
+        "url": "https://github.com/cheeriojs/dom-serializer?sponsor=1"
+      }
+    },
+    "node_modules/domelementtype": {
+      "version": "2.3.0",
+      "resolved": "https://registry.npmjs.org/domelementtype/-/domelementtype-2.3.0.tgz",
+      "integrity": "sha512-OLETBj6w0OsagBwdXnPdN0cnMfF9opN69co+7ZrbfPGrdpPVNBUj02spi6B1N7wChLQiPn4CSH/zJvXw56gmHw==",
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/fb55"
+        }
+      ],
+      "license": "BSD-2-Clause"
+    },
+    "node_modules/domhandler": {
+      "version": "5.0.3",
+      "resolved": "https://registry.npmjs.org/domhandler/-/domhandler-5.0.3.tgz",
+      "integrity": "sha512-cgwlv/1iFQiFnU96XXgROh8xTeetsnJiDsTc7TYCLFd9+/WNkIqPTxiM/8pSd8VIrhXGTf1Ny1q1hquVqDJB5w==",
+      "license": "BSD-2-Clause",
+      "dependencies": {
+        "domelementtype": "^2.3.0"
+      },
+      "engines": {
+        "node": ">= 4"
+      },
+      "funding": {
+        "url": "https://github.com/fb55/domhandler?sponsor=1"
+      }
+    },
+    "node_modules/domutils": {
+      "version": "3.2.2",
+      "resolved": "https://registry.npmjs.org/domutils/-/domutils-3.2.2.tgz",
+      "integrity": "sha512-6kZKyUajlDuqlHKVX1w7gyslj9MPIXzIFiz/rGu35uC1wMi+kMhQwGhl4lt9unC9Vb9INnY9Z3/ZA3+FhASLaw==",
+      "license": "BSD-2-Clause",
+      "dependencies": {
+        "dom-serializer": "^2.0.0",
+        "domelementtype": "^2.3.0",
+        "domhandler": "^5.0.3"
+      },
+      "funding": {
+        "url": "https://github.com/fb55/domutils?sponsor=1"
+      }
+    },
     "node_modules/dunder-proto": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
@@ -6157,6 +6300,18 @@
         "node": ">=10.13.0"
       }
     },
+    "node_modules/entities": {
+      "version": "4.5.0",
+      "resolved": "https://registry.npmjs.org/entities/-/entities-4.5.0.tgz",
+      "integrity": "sha512-V0hjH4dGPh9Ao5p0MoRY6BVqtwCjhz6vI5LT8AJ55H+4g9/4vbHx1I54fS0XuclLhDHArPQCiMjDxjaL8fPxhw==",
+      "license": "BSD-2-Clause",
+      "engines": {
+        "node": ">=0.12"
+      },
+      "funding": {
+        "url": "https://github.com/fb55/entities?sponsor=1"
+      }
+    },
     "node_modules/error-ex": {
       "version": "1.3.2",
       "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz",
@@ -7397,6 +7552,41 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/html-to-text": {
+      "version": "9.0.5",
+      "resolved": "https://registry.npmjs.org/html-to-text/-/html-to-text-9.0.5.tgz",
+      "integrity": "sha512-qY60FjREgVZL03vJU6IfMV4GDjGBIoOyvuFdpBDIX9yTlDw0TjxVBQp+P8NvpdIXNJvfWBTNul7fsAQJq2FNpg==",
+      "license": "MIT",
+      "dependencies": {
+        "@selderee/plugin-htmlparser2": "^0.11.0",
+        "deepmerge": "^4.3.1",
+        "dom-serializer": "^2.0.0",
+        "htmlparser2": "^8.0.2",
+        "selderee": "^0.11.0"
+      },
+      "engines": {
+        "node": ">=14"
+      }
+    },
+    "node_modules/htmlparser2": {
+      "version": "8.0.2",
+      "resolved": "https://registry.npmjs.org/htmlparser2/-/htmlparser2-8.0.2.tgz",
+      "integrity": "sha512-GYdjWKDkbRLkZ5geuHs5NY1puJ+PXwP7+fHPRz06Eirsb9ugf6d8kkXav6ADhcODhFFPMIXyxkxSuMf3D6NCFA==",
+      "funding": [
+        "https://github.com/fb55/htmlparser2?sponsor=1",
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/fb55"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "domelementtype": "^2.3.0",
+        "domhandler": "^5.0.3",
+        "domutils": "^3.0.1",
+        "entities": "^4.4.0"
+      }
+    },
     "node_modules/http-cache-semantics": {
       "version": "4.2.0",
       "resolved": "https://registry.npmjs.org/http-cache-semantics/-/http-cache-semantics-4.2.0.tgz",
@@ -8181,6 +8371,21 @@
         "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
       }
     },
+    "node_modules/jest-mock-extended": {
+      "version": "4.0.0",
+      "resolved": "https://registry.npmjs.org/jest-mock-extended/-/jest-mock-extended-4.0.0.tgz",
+      "integrity": "sha512-7BZpfuvLam+/HC+NxifIi9b+5VXj/utUDMPUqrDJehGWVuXPtLS9Jqlob2mJLrI/pg2k1S8DMfKDvEB88QNjaQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "ts-essentials": "^10.0.2"
+      },
+      "peerDependencies": {
+        "@jest/globals": "^28.0.0 || ^29.0.0 || ^30.0.0",
+        "jest": "^24.0.0 || ^25.0.0 || ^26.0.0 || ^27.0.0 || ^28.0.0 || ^29.0.0 || ^30.0.0",
+        "typescript": "^3.0.0 || ^4.0.0 || ^5.0.0"
+      }
+    },
     "node_modules/jest-pnp-resolver": {
       "version": "1.2.3",
       "resolved": "https://registry.npmjs.org/jest-pnp-resolver/-/jest-pnp-resolver-1.2.3.tgz",
@@ -8676,6 +8881,15 @@
         "node": ">=6"
       }
     },
+    "node_modules/leac": {
+      "version": "0.6.0",
+      "resolved": "https://registry.npmjs.org/leac/-/leac-0.6.0.tgz",
+      "integrity": "sha512-y+SqErxb8h7nE/fiEX07jsbuhrpO9lL8eca7/Y1nuWV2moNlXhyd59iDGcRf6moVyDMbmTNzL40SUyrFU/yDpg==",
+      "license": "MIT",
+      "funding": {
+        "url": "https://ko-fi.com/killymxi"
+      }
+    },
     "node_modules/leven": {
       "version": "3.1.0",
       "resolved": "https://registry.npmjs.org/leven/-/leven-3.1.0.tgz",
@@ -8700,6 +8914,12 @@
         "node": ">= 0.8.0"
       }
     },
+    "node_modules/libphonenumber-js": {
+      "version": "1.12.9",
+      "resolved": "https://registry.npmjs.org/libphonenumber-js/-/libphonenumber-js-1.12.9.tgz",
+      "integrity": "sha512-VWwAdNeJgN7jFOD+wN4qx83DTPMVPPAUyx9/TUkBXKLiNkuWWk6anV0439tgdtwaJDrEdqkvdN22iA6J4bUCZg==",
+      "license": "MIT"
+    },
     "node_modules/lines-and-columns": {
       "version": "1.2.4",
       "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
@@ -9227,6 +9447,15 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/nodemailer": {
+      "version": "7.0.4",
+      "resolved": "https://registry.npmjs.org/nodemailer/-/nodemailer-7.0.4.tgz",
+      "integrity": "sha512-9O00Vh89/Ld2EcVCqJ/etd7u20UhME0f/NToPfArwPEe1Don1zy4mAIz6ariRr7mJ2RDxtaDzN0WJVdVXPtZaw==",
+      "license": "MIT-0",
+      "engines": {
+        "node": ">=6.0.0"
+      }
+    },
     "node_modules/normalize-path": {
       "version": "3.0.0",
       "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
@@ -9487,6 +9716,19 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/parseley": {
+      "version": "0.12.1",
+      "resolved": "https://registry.npmjs.org/parseley/-/parseley-0.12.1.tgz",
+      "integrity": "sha512-e6qHKe3a9HWr0oMRVDTRhKce+bRO8VGQR3NyVwcjwrbhMmFCX9KszEV35+rn4AdilFAq9VPxP/Fe1wC9Qjd2lw==",
+      "license": "MIT",
+      "dependencies": {
+        "leac": "^0.6.0",
+        "peberminta": "^0.9.0"
+      },
+      "funding": {
+        "url": "https://ko-fi.com/killymxi"
+      }
+    },
     "node_modules/parseurl": {
       "version": "1.3.3",
       "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
@@ -9631,6 +9873,15 @@
       "resolved": "https://registry.npmjs.org/pause/-/pause-0.0.1.tgz",
       "integrity": "sha512-KG8UEiEVkR3wGEb4m5yZkVCzigAD+cVEJck2CzYZO37ZGJfctvVptVO192MwrtPhzONn6go8ylnOdMhKqi4nfg=="
     },
+    "node_modules/peberminta": {
+      "version": "0.9.0",
+      "resolved": "https://registry.npmjs.org/peberminta/-/peberminta-0.9.0.tgz",
+      "integrity": "sha512-XIxfHpEuSJbITd1H3EeQwpcZbTLHc+VVr8ANI9t5sit565tsI4/xK3KWTUFE2e6QiangUkh3B0jihzmGnNrRsQ==",
+      "license": "MIT",
+      "funding": {
+        "url": "https://ko-fi.com/killymxi"
+      }
+    },
     "node_modules/peek-readable": {
       "version": "5.4.2",
       "resolved": "https://registry.npmjs.org/peek-readable/-/peek-readable-5.4.2.tgz",
@@ -9785,7 +10036,6 @@
       "version": "3.6.2",
       "resolved": "https://registry.npmjs.org/prettier/-/prettier-3.6.2.tgz",
       "integrity": "sha512-I7AIg5boAr5R0FFtJ6rCfD+LFsWHp81dolrFD8S79U9tb8Az2nGrJncnMSnys+bpQJfRUzqs9hnA81OAA3hCuQ==",
-      "dev": true,
       "license": "MIT",
       "bin": {
         "prettier": "bin/prettier.cjs"
@@ -10007,6 +10257,21 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/react-promise-suspense": {
+      "version": "0.3.4",
+      "resolved": "https://registry.npmjs.org/react-promise-suspense/-/react-promise-suspense-0.3.4.tgz",
+      "integrity": "sha512-I42jl7L3Ze6kZaq+7zXWSunBa3b1on5yfvUW6Eo/3fFOj6dZ5Bqmcd264nJbTK/gn1HjjILAjSwnZbV4RpSaNQ==",
+      "license": "MIT",
+      "dependencies": {
+        "fast-deep-equal": "^2.0.1"
+      }
+    },
+    "node_modules/react-promise-suspense/node_modules/fast-deep-equal": {
+      "version": "2.0.1",
+      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-2.0.1.tgz",
+      "integrity": "sha512-bCK/2Z4zLidyB4ReuIsvALH6w31YfAQDmXMqMx6FyfHqvBxtjC0eRumeSu4Bs3XtXwpyIywtSTrVT99BxY1f9w==",
+      "license": "MIT"
+    },
     "node_modules/readable-stream": {
       "version": "3.6.2",
       "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
@@ -10071,6 +10336,18 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/resend": {
+      "version": "4.6.0",
+      "resolved": "https://registry.npmjs.org/resend/-/resend-4.6.0.tgz",
+      "integrity": "sha512-D5T2I82FvEUYFlrHzaDvVtr5ADHdhuoLaXgLFGABKyNtQgPWIuz0Vp2L2Evx779qjK37aF4kcw1yXJDHhA2JnQ==",
+      "license": "MIT",
+      "dependencies": {
+        "@react-email/render": "1.1.2"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
     "node_modules/resolve": {
       "version": "1.22.10",
       "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.10.tgz",
@@ -10308,6 +10585,18 @@
         "node": ">= 6"
       }
     },
+    "node_modules/selderee": {
+      "version": "0.11.0",
+      "resolved": "https://registry.npmjs.org/selderee/-/selderee-0.11.0.tgz",
+      "integrity": "sha512-5TF+l7p4+OsnP8BCCvSyZiSPc4x4//p5uPwK8TCnVPJYRmU2aYKMpOXvw8zM5a5JvuuCGN1jmsMwuU2W02ukfA==",
+      "license": "MIT",
+      "dependencies": {
+        "parseley": "^0.12.0"
+      },
+      "funding": {
+        "url": "https://ko-fi.com/killymxi"
+      }
+    },
     "node_modules/semver": {
       "version": "7.7.2",
       "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
@@ -11280,6 +11569,21 @@
         "typescript": ">=4.8.4"
       }
     },
+    "node_modules/ts-essentials": {
+      "version": "10.1.1",
+      "resolved": "https://registry.npmjs.org/ts-essentials/-/ts-essentials-10.1.1.tgz",
+      "integrity": "sha512-4aTB7KLHKmUvkjNj8V+EdnmuVTiECzn3K+zIbRthumvHu+j44x3w63xpfs0JL3NGIzGXqoQ7AV591xHO+XrOTw==",
+      "dev": true,
+      "license": "MIT",
+      "peerDependencies": {
+        "typescript": ">=4.5.0"
+      },
+      "peerDependenciesMeta": {
+        "typescript": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/ts-jest": {
       "version": "29.4.0",
       "resolved": "https://registry.npmjs.org/ts-jest/-/ts-jest-29.4.0.tgz",
@@ -11689,6 +11993,15 @@
         "node": ">=10.12.0"
       }
     },
+    "node_modules/validator": {
+      "version": "13.15.15",
+      "resolved": "https://registry.npmjs.org/validator/-/validator-13.15.15.tgz",
+      "integrity": "sha512-BgWVbCI72aIQy937xbawcs+hrVaN/CZ2UwutgaJ36hGqRrLNM+f5LUT/YPRbo8IV/ASeFzXszezV+y2+rq3l8A==",
+      "license": "MIT",
+      "engines": {
+        "node": ">= 0.10"
+      }
+    },
     "node_modules/vary": {
       "version": "1.1.2",
       "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
diff --git a/package.json b/package.json
index 97709b5..e5ffaa9 100644
--- a/package.json
+++ b/package.json
@@ -23,6 +23,7 @@
     "@nestjs/common": "^11.0.1",
     "@nestjs/core": "^11.1.3",
     "@nestjs/jwt": "^11.0.0",
+    "@nestjs/mapped-types": "^2.1.0",
     "@nestjs/passport": "^11.0.5",
     "@nestjs/platform-express": "^11.0.1",
     "@prisma/client": "^6.10.1",
@@ -32,18 +33,23 @@
     "@types/passport-jwt": "^4.0.1",
     "@types/passport-local": "^1.0.38",
     "bcryptjs": "^3.0.2",
+    "class-transformer": "^0.5.1",
+    "class-validator": "^0.14.2",
     "jsonwebtoken": "^9.0.2",
+    "nodemailer": "^7.0.4",
     "passport": "^0.7.0",
     "passport-jwt": "^4.0.1",
     "passport-local": "^1.0.0",
     "prisma": "^6.10.1",
     "reflect-metadata": "^0.2.2",
+    "resend": "^4.6.0",
     "rxjs": "^7.8.1",
     "zod": "^3.25.67"
   },
   "devDependencies": {
     "@eslint/eslintrc": "^3.2.0",
     "@eslint/js": "^9.18.0",
+    "@golevelup/nestjs-testing": "^0.1.2",
     "@nestjs/cli": "^11.0.0",
     "@nestjs/schematics": "^11.0.0",
     "@nestjs/testing": "^11.0.1",
@@ -58,6 +64,7 @@
     "eslint-plugin-prettier": "^5.2.2",
     "globals": "^16.0.0",
     "jest": "^29.7.0",
+    "jest-mock-extended": "^4.0.0",
     "prettier": "^3.4.2",
     "source-map-support": "^0.5.21",
     "supertest": "^7.0.0",
diff --git a/src/__mocks__/user_mocks.ts b/src/__mocks__/user_mocks.ts
new file mode 100644
index 0000000..98eca71
--- /dev/null
+++ b/src/__mocks__/user_mocks.ts
@@ -0,0 +1,21 @@
+import { randomUUID } from 'crypto';
+import { AuthenticatedRequest } from 'src/common/interfaces/authenticated-request.interface';
+import { UserRole } from '@prisma/client'; // Certifique-se de que você está importando a enum correta
+
+function createMockRequest(role: UserRole): AuthenticatedRequest {
+  return {
+    user: {
+      sub: randomUUID(),
+      role,
+    },
+  } as AuthenticatedRequest;
+}
+
+export const adminReq = createMockRequest(UserRole.ADMIN);
+export const studentReq = createMockRequest(UserRole.STUDENT);
+export const professorReq = createMockRequest(UserRole.TEACHER);
+
+// Também exporta os IDs separados, se necessário em testes
+export const adminId = adminReq.user.sub;
+export const studentId = studentReq.user.sub;
+export const professorId = professorReq.user.sub;
diff --git a/src/answer-attempts/answer-attempts.controller.spec.ts b/src/answer-attempts/answer-attempts.controller.spec.ts
index 43e9c28..6eb4066 100644
--- a/src/answer-attempts/answer-attempts.controller.spec.ts
+++ b/src/answer-attempts/answer-attempts.controller.spec.ts
@@ -1,18 +1,38 @@
+/* eslint-disable @typescript-eslint/no-unsafe-member-access */
+/* eslint-disable @typescript-eslint/unbound-method */
+import {
+  adminId,
+  adminReq,
+  studentId,
+  studentReq,
+} from '../__mocks__/user_mocks';
 import { Test, TestingModule } from '@nestjs/testing';
+import { randomUUID } from 'crypto';
+import {
+  BadRequestException,
+  NotFoundException,
+  ForbiddenException,
+  ParseUUIDPipe,
+} from '@nestjs/common';
 import { AnswerAttemptsController } from './answer-attempts.controller';
+import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
 import { AnswerAttemptsService } from './answer-attempts.service';
-import { PrismaService } from '../prisma/prisma.service';
-import { randomUUID } from 'crypto';
-import { AuthenticatedRequest } from 'src/common/interfaces/authenticated-request.interface';
+import {
+  CreateAnswerAttemptDto,
+  UpdateAnswerAttemptDto,
+} from './answer-attempts.dto';
+import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
 
 describe('AnswerAttemptsController', () => {
   let controller: AnswerAttemptsController;
+  let service: DeepMockProxy<AnswerAttemptsService>;
 
-  const userId = randomUUID();
+  // IDs de exemplo para mocks
   const questionId = randomUUID();
   const attemptId = randomUUID();
   const answerId = randomUUID();
 
+  // Mock de tentativa de resposta com estrutura compatível com seu service
   const mockAnswerAttempt = {
     id: attemptId,
     answerId,
@@ -20,185 +40,99 @@ describe('AnswerAttemptsController', () => {
     timeSpent: 120,
     attemptAt: new Date(),
     answer: {
-      userId,
+      id: randomUUID(),
+      isCorrect: null,
+      userId: studentId,
       questionId,
+      selectedOption: null,
+      textAnswer: null,
+      timeSpentSeconds: null,
+      answeredAt: new Date(),
     },
   };
 
-  const mockPrismaService = {
-    answerAttempt: {
-      findMany: jest.fn(),
-      findUnique: jest.fn(),
-      create: jest.fn(),
-      update: jest.fn(),
-      delete: jest.fn(),
-    },
-    answer: {
-      findUnique: jest.fn(),
-    },
-  };
-
-  const mockUserAdmin: AuthenticatedRequest = {
-    user: {
-      sub: randomUUID(),
-      role: 'ADMIN',
-    },
-  } as AuthenticatedRequest;
-
-  const mockUserStudent: AuthenticatedRequest = {
-    user: {
-      sub: userId, // igual ao da tentativa
-      role: 'STUDENT',
-    },
-  } as AuthenticatedRequest;
-
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
       controllers: [AnswerAttemptsController],
       providers: [
-        AnswerAttemptsService,
-        { provide: PrismaService, useValue: mockPrismaService },
+        {
+          provide: AnswerAttemptsService,
+          useValue: mockDeep<AnswerAttemptsService>(),
+        },
       ],
     }).compile();
 
     controller = module.get<AnswerAttemptsController>(AnswerAttemptsController);
+    service = module.get(AnswerAttemptsService);
   });
 
-  afterEach(() => {
-    jest.clearAllMocks();
-  });
+  afterEach(() => jest.clearAllMocks());
+
+  // --- findAll ---
 
-  /*** FIND ALL ***/
   describe('findAll', () => {
     it('deve retornar lista para ADMIN', async () => {
-      mockPrismaService.answerAttempt.findMany.mockResolvedValue([
-        mockAnswerAttempt,
-      ]);
-
-      const result = await controller.findAll(mockUserAdmin);
+      service.findAll.mockResolvedValue([mockAnswerAttempt]);
 
-      expect(result).toEqual([mockAnswerAttempt]);
-      expect(mockPrismaService.answerAttempt.findMany).toHaveBeenCalledTimes(1);
-    });
-
-    it('deve aplicar filtros e paginação para ADMIN', async () => {
-      mockPrismaService.answerAttempt.findMany.mockResolvedValue([
-        mockAnswerAttempt,
-      ]);
-
-      const result = await controller.findAll(
-        mockUserAdmin,
-        userId,
-        questionId,
-        'true',
-        '10',
-        '5',
-      );
-
-      expect(result).toEqual([mockAnswerAttempt]);
-      expect(mockPrismaService.answerAttempt.findMany).toHaveBeenCalledWith(
-        expect.objectContaining({
-          where: {
-            answer: {
-              userId,
-              questionId,
-            },
-            isCorrect: true,
-          },
-          take: 10,
-          skip: 5,
-        }),
-      );
-    });
-
-    it('deve retornar tentativas do próprio STUDENT', async () => {
-      mockPrismaService.answerAttempt.findMany.mockResolvedValue([
-        mockAnswerAttempt,
-      ]);
-
-      const result = await controller.findAll(mockUserStudent, userId);
+      const result = await controller.findAll(adminReq, {});
 
       expect(result).toEqual([mockAnswerAttempt]);
-      expect(mockPrismaService.answerAttempt.findMany).toHaveBeenCalledWith(
-        expect.objectContaining({
-          where: {
-            answer: {
-              userId,
-            },
-          },
-        }),
-      );
+      expect(service.findAll).toHaveBeenCalledTimes(1);
     });
 
-    it('deve lançar erro 403 para STUDENT acessando tentativas de outro user', async () => {
+    it('deve lançar ForbiddenException para STUDENT acessando tentativas de outro user', async () => {
       await expect(
-        controller.findAll(mockUserStudent, randomUUID()),
-      ).rejects.toThrow('Não autorizado.');
+        controller.findAll(studentReq, { userId: randomUUID() }),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
-  /*** CREATE ***/
+  // --- create ---
+
   describe('create', () => {
-    const newAttemptDto = {
+    const newAttemptDto: CreateAnswerAttemptDto = {
       answerId,
       isCorrect: true,
       timeSpent: 60,
+      attemptAt: new Date(),
     };
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { answerId: "", isCorrect: true, timeSpent: 60 };
-      await expect(controller.create(invalidDto, mockUserAdmin)).rejects.toThrow(BadRequestException);
-    });
-
-    it("deve criar tentativa como ADMIN", async () => {
-      mockPrismaService.answer.findUnique.mockResolvedValue({ userId });
-      mockPrismaService.answerAttempt.create.mockResolvedValue({
-        id: attemptId,
-        ...newAttemptDto,
-      });
-
-      const result = await controller.create(newAttemptDto, mockUserAdmin);
-
-      expect(result).toMatchObject({
-        id: attemptId,
-        answerId,
-      });
+    it('deve lançar ForbiddenException se não autenticado', async () => {
+      await expect(
+        controller.create(newAttemptDto, {} as AuthenticatedRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it('deve criar tentativa como STUDENT para si mesmo', async () => {
-      mockPrismaService.answer.findUnique.mockResolvedValue({ userId });
-      mockPrismaService.answerAttempt.create.mockResolvedValue({
-        id: attemptId,
-        ...newAttemptDto,
-      });
+    it('deve criar tentativa com sucesso', async () => {
+      service.findAnswer.mockResolvedValue({ userId: adminId });
+      service.create.mockResolvedValue(mockAnswerAttempt);
 
-      const result = await controller.create(newAttemptDto, mockUserStudent);
+      const result = await controller.create(newAttemptDto, adminReq);
 
-      expect(result.answerId).toBe(answerId);
+      expect(result).toEqual(mockAnswerAttempt);
     });
 
-    it('deve lançar erro se resposta não existe', async () => {
-      mockPrismaService.answer.findUnique.mockResolvedValue(null);
+    it('deve lançar NotFoundException se resposta não existir', async () => {
+      service.findAnswer.mockResolvedValue(null);
 
-      await expect(
-        controller.create(newAttemptDto, mockUserAdmin),
-      ).rejects.toThrow('Resposta não encontrada.');
+      await expect(controller.create(newAttemptDto, adminReq)).rejects.toThrow(
+        NotFoundException,
+      );
     });
 
-    it('deve lançar erro 403 para STUDENT criando de outro userId', async () => {
-      mockPrismaService.answer.findUnique.mockResolvedValue({
-        userId: 'outro-id',
-      });
+    it('deve lançar ForbiddenException para STUDENT criando tentativa de outro user', async () => {
+      service.findAnswer.mockResolvedValue({ userId: 'outro-id' });
 
       await expect(
-        controller.create(newAttemptDto, mockUserStudent),
-      ).rejects.toThrow('Não autorizado.');
+        controller.create(newAttemptDto, studentReq),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
-  /*** UPDATE ***/
+  // --- update ---
+
   describe('update', () => {
-    const updateDto = {
+    const updateDto: UpdateAnswerAttemptDto = {
       id: attemptId,
       answerId,
       isCorrect: true,
@@ -206,68 +140,76 @@ describe('AnswerAttemptsController', () => {
       attemptAt: new Date(),
     };
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { answerId: "", isCorrect: true, timeSpent: 80 };
-      await expect(controller.update(attemptId, invalidDto, mockUserAdmin)).rejects.toThrow(BadRequestException);
+    it('deve lançar ForbiddenException se não autenticado', async () => {
+      await expect(
+        controller.update(attemptId, updateDto, {} as AuthenticatedRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("deve atualizar como ADMIN", async () => {
-      mockPrismaService.answerAttempt.findUnique.mockResolvedValue(
-        mockAnswerAttempt,
-      );
-      mockPrismaService.answer.findUnique.mockResolvedValue({ userId });
-      mockPrismaService.answerAttempt.update.mockResolvedValue(updateDto);
+    it('deve lançar BadRequestException se id da rota e do DTO forem diferentes', async () => {
+      await expect(
+        controller.update(randomUUID(), updateDto, adminReq),
+      ).rejects.toThrow(BadRequestException);
+    });
 
-      const result = await controller.update(
-        attemptId,
-        updateDto,
-        mockUserAdmin,
-      );
+    it('deve atualizar com sucesso', async () => {
+      service.findOne.mockResolvedValue(mockAnswerAttempt);
+      service.update.mockResolvedValue({
+        ...mockAnswerAttempt,
+        isCorrect: true,
+      });
+
+      const result = await controller.update(attemptId, updateDto, adminReq);
 
       expect(result.isCorrect).toBe(true);
-      expect(mockPrismaService.answerAttempt.update).toHaveBeenCalledWith(
-        expect.objectContaining({
-          where: { id: attemptId },
-          data: updateDto,
-        }),
-      );
     });
 
-    it('deve lançar erro se tentativa não existe', async () => {
-      mockPrismaService.answerAttempt.findUnique.mockResolvedValue(null);
+    it('deve lançar NotFoundException se tentativa não existir', async () => {
+      service.findOne.mockResolvedValue(null);
 
       await expect(
-        controller.update(attemptId, updateDto, mockUserAdmin),
-      ).rejects.toThrow('Tentativa de resposta não encontrada.');
+        controller.update(attemptId, updateDto, adminReq),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
-  /*** DELETE ***/
+  // --- remove ---
+
   describe('remove', () => {
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockUserAdmin)).rejects.toThrow(BadRequestException);
+    it('deve lançar ForbiddenException se não autenticado', async () => {
+      await expect(
+        controller.remove(attemptId, {} as AuthenticatedRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("deve remover como ADMIN", async () => {
-      mockPrismaService.answerAttempt.findUnique.mockResolvedValue(
-        mockAnswerAttempt,
-      );
-      mockPrismaService.answerAttempt.delete.mockResolvedValue(
-        mockAnswerAttempt,
-      );
+    it('deve lançar BadRequestException se ID inválido', async () => {
+      const pipe = new ParseUUIDPipe();
+
+      // Testa o pipe isoladamente, pois ele é executado na camada HTTP, antes do controller
+      await expect(
+        pipe.transform('invalid-uuid', { type: 'param', data: '' }),
+      ).rejects.toThrow(BadRequestException);
+
+      // No teste unitário do controller, a validação do pipe não é executada
+      // Para testar o pipe integrado, faça testes e2e (integração)
+    });
+
+    it('deve remover com sucesso', async () => {
+      service.findOne.mockResolvedValue(mockAnswerAttempt);
+      service.remove.mockResolvedValue(mockAnswerAttempt);
 
-      const result = await controller.remove(attemptId, mockUserAdmin);
+      const response = await controller.remove(attemptId, adminReq);
 
-      expect(result).toEqual({
+      expect(response).toEqual({
         message: 'Tentativa de resposta deletada com sucesso.',
       });
     });
 
-    it('deve lançar erro se tentativa não existe', async () => {
-      mockPrismaService.answerAttempt.findUnique.mockResolvedValue(null);
+    it('deve lançar NotFoundException se tentativa não existir', async () => {
+      service.findOne.mockResolvedValue(null);
 
-      await expect(controller.remove(attemptId, mockUserAdmin)).rejects.toThrow(
-        'Tentativa de resposta não encontrada.',
+      await expect(controller.remove(attemptId, adminReq)).rejects.toThrow(
+        NotFoundException,
       );
     });
   });
diff --git a/src/answer-attempts/answer-attempts.controller.ts b/src/answer-attempts/answer-attempts.controller.ts
index faf6862..666551a 100644
--- a/src/answer-attempts/answer-attempts.controller.ts
+++ b/src/answer-attempts/answer-attempts.controller.ts
@@ -8,84 +8,47 @@ import {
   Delete,
   UseGuards,
   Request,
-  Query,
   BadRequestException,
   ForbiddenException,
   NotFoundException,
+  Query,
+  ParseUUIDPipe,
 } from '@nestjs/common';
 import { AnswerAttemptsService } from './answer-attempts.service';
 import { JwtAuthGuard } from '../auth/jwt-auth.guard/jwt-auth.guard';
-import { z, ZodError } from 'zod';
 import { Prisma } from '@prisma/client';
 import { AuthenticatedRequest } from 'src/common/interfaces/authenticated-request.interface';
 import {
+  AttemptFilterDto,
   CreateAnswerAttemptDto,
   UpdateAnswerAttemptDto,
 } from './answer-attempts.dto';
 
-// Zod Schemas
-const answerAttemptCreateSchema = z.object({
-  answerId: z
-    .string()
-    .uuid({ message: 'O ID da resposta deve ser um UUID válido.' }),
-  isCorrect: z.boolean(),
-  timeSpent: z
-    .number()
-    .int('O tempo gasto deve ser um número inteiro.')
-    .min(0, 'O tempo gasto deve ser maior ou igual a zero.')
-    .nullable()
-    .optional(),
-  attemptAt: z.union([z.string().datetime(), z.date()]).optional().nullable(),
-});
-
-const answerAttemptUpdateSchema = answerAttemptCreateSchema.extend({
-  id: z.string().uuid('O ID da tentativa deve ser um UUID válido.'),
-});
-
-const idSchema = z.object({
-  id: z.string().uuid('O ID fornecido é inválido.'),
-});
-
 @Controller('answer-attempts')
 export class AnswerAttemptsController {
   constructor(private readonly answerAttemptsService: AnswerAttemptsService) {}
 
-  private handleZodError(error: ZodError) {
-    return error.errors.map((e) => ({
-      path: e.path.join('.'),
-      message: e.message,
-    }));
-  }
-
+  /*** GET - LISTAR TENTATIVAS ***/
   @UseGuards(JwtAuthGuard)
   @Get()
   async findAll(
     @Request() req: AuthenticatedRequest,
-    @Query('userId') userId?: string,
-    @Query('questionId') questionId?: string,
-    @Query('isCorrect') isCorrect?: string,
-    @Query('limit') limit?: string,
-    @Query('offset') offset?: string,
+    @Query() query: AttemptFilterDto,
   ) {
     const { user } = req;
 
     if (!user) throw new ForbiddenException('Não autenticado.');
 
     if (user.role !== 'ADMIN') {
-      if (!userId || userId !== user.sub) {
+      if (!query.userId || query.userId !== user.sub) {
         throw new ForbiddenException('Não autorizado.');
       }
     }
 
-    return this.answerAttemptsService.findAll({
-      userId,
-      questionId,
-      isCorrect,
-      limit,
-      offset,
-    });
+    return this.answerAttemptsService.findAll(query);
   }
 
+  /*** POST - CRIAR TENTATIVA ***/
   @UseGuards(JwtAuthGuard)
   @Post()
   async create(
@@ -93,75 +56,51 @@ export class AnswerAttemptsController {
     @Request() req: AuthenticatedRequest,
   ) {
     const { user } = req;
-
     if (!user) throw new ForbiddenException('Não autenticado.');
 
-    const result = answerAttemptCreateSchema.safeParse(createDto);
+    const answer = await this.answerAttemptsService.findAnswer(
+      createDto.answerId,
+    );
 
-    if (!result.success) {
-      throw new BadRequestException({
-        message: 'Dados inválidos para criação da tentativa de resposta.',
-        errors: this.handleZodError(result.error),
-      });
+    if (!answer) {
+      throw new NotFoundException('Resposta não encontrada.');
     }
 
-    const data = result.data;
-
-    const answer = await this.answerAttemptsService.findAnswer(data.answerId);
-    if (!answer) throw new NotFoundException('Resposta não encontrada.');
-
     if (user.role !== 'ADMIN' && user.sub !== answer.userId) {
       throw new ForbiddenException('Não autorizado.');
     }
 
-    return this.answerAttemptsService.create({
-      ...data,
-      attemptAt: data.attemptAt ? new Date(data.attemptAt) : undefined,
-    });
+    return this.answerAttemptsService.create(createDto);
   }
 
+  /*** PATCH - ATUALIZAR TENTATIVA ***/
   @UseGuards(JwtAuthGuard)
   @Patch(':id')
   async update(
-    @Param('id') id: string,
+    @Param('id', new ParseUUIDPipe({ version: '4' })) id: string,
     @Body() updateDto: UpdateAnswerAttemptDto,
     @Request() req: AuthenticatedRequest,
   ) {
     const { user } = req;
-
     if (!user) throw new ForbiddenException('Não autenticado.');
 
-    const parsedId = idSchema.safeParse({ id });
-    if (!parsedId.success) {
-      throw new BadRequestException({
-        message: 'ID da tentativa de resposta inválido.',
-        errors: this.handleZodError(parsedId.error),
-      });
-    }
-
-    const result = answerAttemptUpdateSchema.safeParse(updateDto);
-    if (!result.success) {
-      throw new BadRequestException({
-        message: 'Dados inválidos para atualização da tentativa de resposta.',
-        errors: this.handleZodError(result.error),
-      });
+    if (id !== updateDto.id) {
+      throw new BadRequestException(
+        'ID do parâmetro não bate com o corpo da requisição.',
+      );
     }
 
-    const attempt = await this.answerAttemptsService.findOne(parsedId.data.id);
-    if (!attempt)
+    const attempt = await this.answerAttemptsService.findOne(id);
+    if (!attempt) {
       throw new NotFoundException('Tentativa de resposta não encontrada.');
+    }
 
     if (user.role !== 'ADMIN' && user.sub !== attempt.answer.userId) {
       throw new ForbiddenException('Não autorizado.');
     }
 
     try {
-      return await this.answerAttemptsService.update(parsedId.data.id, {
-        ...result.data,
-        attemptAt: result.data.attemptAt
-          ? new Date(result.data.attemptAt)
-          : undefined,
-      });
+      return await this.answerAttemptsService.update(id, updateDto);
     } catch (error) {
       if (
         error instanceof Prisma.PrismaClientKnownRequestError &&
@@ -171,50 +110,40 @@ export class AnswerAttemptsController {
           'Tentativa de resposta não encontrada para atualização.',
         );
       }
-      throw new Error(
-        'Erro interno do servidor ao atualizar tentativa de resposta.',
-      );
+      throw new Error('Erro interno ao atualizar tentativa de resposta.');
     }
   }
 
+  /*** DELETE - REMOVER TENTATIVA ***/
   @UseGuards(JwtAuthGuard)
   @Delete(':id')
-  async remove(@Param('id') id: string, @Request() req: AuthenticatedRequest) {
+  async remove(
+    @Param('id', new ParseUUIDPipe({ version: '4' })) id: string,
+    @Request() req: AuthenticatedRequest,
+  ) {
     const { user } = req;
-
     if (!user) throw new ForbiddenException('Não autenticado.');
 
-    const parsedId = idSchema.safeParse({ id });
-    if (!parsedId.success) {
-      throw new BadRequestException({
-        message: 'ID da tentativa de resposta inválido.',
-        errors: this.handleZodError(parsedId.error),
-      });
-    }
-
-    const attempt = await this.answerAttemptsService.findOne(parsedId.data.id);
-    if (!attempt)
+    const attempt = await this.answerAttemptsService.findOne(id);
+    if (!attempt) {
       throw new NotFoundException('Tentativa de resposta não encontrada.');
+    }
 
     if (user.role !== 'ADMIN' && user.sub !== attempt.answer.userId) {
       throw new ForbiddenException('Não autorizado.');
     }
 
     try {
-      await this.answerAttemptsService.remove(parsedId.data.id);
+      await this.answerAttemptsService.remove(id);
       return { message: 'Tentativa de resposta deletada com sucesso.' };
     } catch (error) {
       if (
         error instanceof Prisma.PrismaClientKnownRequestError &&
         error.code === 'P2025'
       ) {
-        throw new NotFoundException(
-          'Tentativa de resposta não encontrada para exclusão.',
-        );
+        throw new NotFoundException('Tentativa não encontrada para exclusão.');
       }
-      throw new Error(
-        'Erro interno do servidor ao excluir tentativa de resposta.',
-      );
+      throw new Error('Erro interno ao excluir tentativa de resposta.');
     }
   }
 }
diff --git a/src/answer-attempts/answer-attempts.dto.ts b/src/answer-attempts/answer-attempts.dto.ts
index 20c75c6..c83acbf 100644
--- a/src/answer-attempts/answer-attempts.dto.ts
+++ b/src/answer-attempts/answer-attempts.dto.ts
@@ -1,10 +1,76 @@
+import { Transform } from 'class-transformer';
+import {
+  IsBoolean,
+  IsOptional,
+  IsNumber,
+  IsDate,
+  IsUUID,
+  Min,
+  ValidateIf,
+  IsBooleanString,
+  IsInt,
+} from 'class-validator';
+
 export class CreateAnswerAttemptDto {
-  answerId: string;
-  isCorrect: boolean;
+  @IsUUID('4', { message: 'O ID da resposta deve ser um UUID válido.' })
+  answerId!: string;
+
+  @IsBoolean({ message: 'O campo "isCorrect" deve ser booleano.' })
+  isCorrect!: boolean;
+
+  @IsOptional()
+  @IsNumber({}, { message: 'O tempo gasto deve ser um número.' })
+  @Min(0, { message: 'O tempo gasto não pode ser negativo.' })
+  @ValidateIf((o: CreateAnswerAttemptDto) => o.timeSpent !== null)
+  timeSpent?: number | null;
+
+  @IsOptional()
+  @IsDate({ message: 'A data da tentativa deve ser uma data válida.' })
+  attemptAt?: Date;
+}
+
+export class UpdateAnswerAttemptDto {
+  @IsUUID('4', { message: 'O ID da tentativa deve ser um UUID válido.' })
+  id!: string;
+
+  @IsUUID('4')
+  answerId!: string;
+
+  @IsBoolean()
+  isCorrect!: boolean;
+
+  @IsOptional()
+  @IsNumber()
   timeSpent?: number | null;
+
+  @IsOptional()
+  @IsDate()
   attemptAt?: Date;
 }
 
-export class UpdateAnswerAttemptDto extends CreateAnswerAttemptDto {
-  id: string;
+// src/answer-attempts/dto/attempt-filter.dto.ts
+export class AttemptFilterDto {
+  @IsOptional()
+  @IsUUID()
+  userId?: string;
+
+  @IsOptional()
+  @IsUUID()
+  questionId?: string;
+
+  @IsOptional()
+  @IsBooleanString()
+  isCorrect?: string;
+
+  @IsOptional()
+  @Transform(({ value }: { value: string }) => parseInt(value))
+  @IsInt()
+  @Min(0)
+  limit?: number;
+
+  @IsOptional()
+  @Transform(({ value }: { value: string }) => parseInt(value))
+  @IsInt()
+  @Min(0)
+  offset?: number;
 }
diff --git a/src/answer-attempts/answer-attempts.service.spec.ts b/src/answer-attempts/answer-attempts.service.spec.ts
index ae15a4a..3ecedd1 100644
--- a/src/answer-attempts/answer-attempts.service.spec.ts
+++ b/src/answer-attempts/answer-attempts.service.spec.ts
@@ -1,25 +1,15 @@
+/* eslint-disable @typescript-eslint/unbound-method */
 import { Test, TestingModule } from '@nestjs/testing';
-import { AnswerAttemptsService, Filters } from './answer-attempts.service';
+import { AnswerAttemptsService } from './answer-attempts.service';
 import { PrismaService } from '../prisma/prisma.service';
-import { randomUUID } from 'crypto';
 import { Prisma } from '@prisma/client';
+import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
+import { randomUUID } from 'crypto';
+import { AttemptFilterDto } from './answer-attempts.dto';
 
 describe('AnswerAttemptsService', () => {
   let service: AnswerAttemptsService;
-
-  // Tipagem parcial para evitar any
-  const mockPrismaService = {
-    answerAttempt: {
-      findMany: jest.fn(),
-      findUnique: jest.fn(),
-      create: jest.fn(),
-      update: jest.fn(),
-      delete: jest.fn(),
-    },
-    answer: {
-      findUnique: jest.fn(),
-    },
-  };
+  let prisma: DeepMockProxy<PrismaService>;
 
   const attemptId = randomUUID();
   const answerId = randomUUID();
@@ -29,20 +19,27 @@ describe('AnswerAttemptsService', () => {
     id: attemptId,
     answerId,
     isCorrect: true,
-    timeSpent: 50,
+    timeSpent: 60,
     attemptAt: new Date('2023-01-01T00:00:00Z'),
-    answer: { userId },
+    answer: {
+      userId,
+      questionId: 'question-id',
+    },
   };
 
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
       providers: [
         AnswerAttemptsService,
-        { provide: PrismaService, useValue: mockPrismaService },
+        {
+          provide: PrismaService,
+          useValue: mockDeep<PrismaService>(),
+        },
       ],
     }).compile();
 
     service = module.get<AnswerAttemptsService>(AnswerAttemptsService);
+    prisma = module.get(PrismaService);
   });
 
   afterEach(() => {
@@ -50,57 +47,49 @@ describe('AnswerAttemptsService', () => {
   });
 
   describe('findAll', () => {
-    it('deve chamar findMany com filtros e retornar resultados', async () => {
-      mockPrismaService.answerAttempt.findMany.mockResolvedValue([mockAttempt]);
+    it('deve retornar resultados com todos os filtros aplicados', async () => {
+      prisma.answerAttempt.findMany.mockResolvedValue([mockAttempt]);
 
-      const filters: Filters = {
+      const filters: AttemptFilterDto = {
         userId,
         questionId: 'question-id',
         isCorrect: 'true',
-        limit: '5',
-        offset: '0',
+        limit: 5,
+        offset: 0,
       };
 
       const result = await service.findAll(filters);
 
-      const expectedArgs: Parameters<
-        typeof mockPrismaService.answerAttempt.findMany
-      >[0] = {
+      expect(prisma.answerAttempt.findMany).toHaveBeenCalledWith({
         where: {
           answer: {
-            userId: filters.userId,
-            questionId: filters.questionId,
+            userId,
+            questionId: 'question-id',
           },
           isCorrect: true,
         },
+        include: { answer: true },
         take: 5,
         skip: 0,
-        include: { answer: true },
         orderBy: { attemptAt: 'desc' },
-      };
-
-      expect(mockPrismaService.answerAttempt.findMany).toHaveBeenCalledWith(
-        expect.objectContaining(expectedArgs),
-      );
+      });
 
       expect(result).toEqual([mockAttempt]);
     });
 
     it('deve funcionar com filtros parciais', async () => {
-      mockPrismaService.answerAttempt.findMany.mockResolvedValue([mockAttempt]);
+      prisma.answerAttempt.findMany.mockResolvedValue([mockAttempt]);
 
-      const filters: Partial<Filters> = {
+      const filters: AttemptFilterDto = {
         userId,
       };
 
-      const result = await service.findAll(filters as Filters);
+      const result = await service.findAll(filters);
 
-      expect(mockPrismaService.answerAttempt.findMany).toHaveBeenCalledWith(
-        expect.objectContaining<Prisma.AnswerAttemptFindManyArgs>({
+      expect(prisma.answerAttempt.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
           where: {
-            answer: {
-              userId,
-            },
+            answer: { userId },
           },
         }),
       );
@@ -110,125 +99,178 @@ describe('AnswerAttemptsService', () => {
   });
 
   describe('findOne', () => {
-    it('deve retornar tentativa pelo id', async () => {
-      mockPrismaService.answerAttempt.findUnique.mockResolvedValue(mockAttempt);
+    it('deve retornar tentativa existente', async () => {
+      prisma.answerAttempt.findUnique.mockResolvedValue(mockAttempt);
 
       const result = await service.findOne(attemptId);
 
-      expect(mockPrismaService.answerAttempt.findUnique).toHaveBeenCalledWith(
-        expect.objectContaining({
-          where: { id: attemptId },
-          include: { answer: { select: { userId: true } } },
-        }),
-      );
+      expect(prisma.answerAttempt.findUnique).toHaveBeenCalledWith({
+        where: { id: attemptId },
+        include: { answer: { select: { userId: true } } },
+      });
+
       expect(result).toEqual(mockAttempt);
     });
 
-    it('deve retornar null se não encontrar', async () => {
-      mockPrismaService.answerAttempt.findUnique.mockResolvedValue(null);
+    it('deve retornar null se tentativa não existir', async () => {
+      prisma.answerAttempt.findUnique.mockResolvedValue(null);
 
-      const result = await service.findOne('id-inexistente');
+      const result = await service.findOne('non-existent-id');
 
       expect(result).toBeNull();
     });
   });
 
   describe('findAnswer', () => {
-    it('deve retornar resposta pelo id', async () => {
-      mockPrismaService.answer.findUnique.mockResolvedValue({ userId });
-
-      const result = await service.findAnswer(answerId);
+    it('deve retornar usuário da resposta', async () => {
+      // Criando o mock manualmente com a estrutura necessária
+      const mockAnswer = {
+        id: '96bd9465-06d1-4ba0-b820-1393324537f2', // Gerar ID único
+        userId: 'some-user-id', // Propriedade que você já tinha
+        questionId: 'some-question-id', // Adicionando questionId
+        selectedOption: null, // Adicionando selectedOption
+        textAnswer: null, // Adicionando textAnswer
+        isCorrect: null, // Adicionando isCorrect
+        timeSpentSeconds: null, // Adicionando timeSpentSeconds
+        answeredAt: new Date(), // Adicionando answeredAt
+      };
+      prisma.answer.findUnique.mockResolvedValue(mockAnswer);
 
-      expect(mockPrismaService.answer.findUnique).toHaveBeenCalledWith(
-        expect.objectContaining({
-          where: { id: answerId },
-          select: { userId: true },
-        }),
+      const result = await service.findAnswer(
+        '96bd9465-06d1-4ba0-b820-1393324537f2',
       );
-      expect(result).toEqual({ userId });
+
+      expect(prisma.answer.findUnique).toHaveBeenCalledWith({
+        where: { id: '96bd9465-06d1-4ba0-b820-1393324537f2' },
+        select: { userId: true },
+      });
+
+      // Verificando o valor esperado
+      expect(result).toEqual(mockAnswer);
     });
   });
 
   describe('create', () => {
-    it('deve criar tentativa', async () => {
+    it('deve criar tentativa com timeSpent definido', async () => {
       const dto = {
         answerId,
         isCorrect: true,
-        timeSpent: 100,
-        attemptAt: new Date(),
+        timeSpent: 90,
+      };
+
+      const createdAttempt = {
+        id: randomUUID(),
+        answerId: dto.answerId,
+        isCorrect: dto.isCorrect,
+        timeSpent: dto.timeSpent,
+        attemptAt: expect.any(Date) as Date,
       };
-      mockPrismaService.answerAttempt.create.mockResolvedValue(dto);
+
+      prisma.answerAttempt.create.mockResolvedValue(createdAttempt);
 
       const result = await service.create(dto);
 
-      expect(mockPrismaService.answerAttempt.create).toHaveBeenCalledWith(
-        expect.objectContaining({
-          data: {
-            answerId: dto.answerId,
-            isCorrect: dto.isCorrect,
-            timeSpent: dto.timeSpent,
-            attemptAt: dto.attemptAt,
-          },
-        }),
-      );
-      expect(result).toEqual(dto);
+      expect(prisma.answerAttempt.create).toHaveBeenCalledWith({
+        data: {
+          answerId: dto.answerId,
+          isCorrect: dto.isCorrect,
+          timeSpent: dto.timeSpent,
+          attemptAt: expect.any(Date) as Date,
+        },
+      });
+
+      expect(result).toEqual(createdAttempt);
+    });
+
+    it('deve criar tentativa com timeSpent como null', async () => {
+      const dto = {
+        answerId,
+        isCorrect: false,
+      };
+
+      const createdAttempt = {
+        id: randomUUID(),
+        answerId: dto.answerId,
+        isCorrect: dto.isCorrect,
+        timeSpent: null,
+        attemptAt: expect.any(Date) as Date,
+      };
+
+      prisma.answerAttempt.create.mockResolvedValue(createdAttempt);
+
+      const result = await service.create(dto);
+
+      expect(prisma.answerAttempt.create).toHaveBeenCalledWith({
+        data: {
+          answerId: dto.answerId,
+          isCorrect: dto.isCorrect,
+          timeSpent: null,
+          attemptAt: expect.any(Date) as Date,
+        },
+      });
+
+      expect(result).toEqual(createdAttempt);
     });
   });
 
   describe('update', () => {
-    it('deve atualizar tentativa', async () => {
-      const dto = { isCorrect: false };
-      mockPrismaService.answerAttempt.update.mockResolvedValue({
+    it('deve atualizar tentativa existente', async () => {
+      const updateDto = { isCorrect: false };
+
+      prisma.answerAttempt.update.mockResolvedValue({
         ...mockAttempt,
-        ...dto,
+        ...updateDto,
       });
 
-      const result = await service.update(attemptId, dto);
+      const result = await service.update(attemptId, updateDto);
 
-      expect(mockPrismaService.answerAttempt.update).toHaveBeenCalledWith(
-        expect.objectContaining({
-          where: { id: attemptId },
-          data: dto,
-        }),
-      );
-      expect(result).toEqual({ ...mockAttempt, ...dto });
+      expect(prisma.answerAttempt.update).toHaveBeenCalledWith({
+        where: { id: attemptId },
+        data: updateDto,
+      });
+
+      expect(result).toEqual({
+        ...mockAttempt,
+        ...updateDto,
+      });
     });
 
-    it('deve lançar erro NotFound para tentativa não existente', async () => {
-      mockPrismaService.answerAttempt.update.mockRejectedValue(
+    it('deve lançar erro se tentativa não for encontrada', async () => {
+      prisma.answerAttempt.update.mockRejectedValue(
         new Prisma.PrismaClientKnownRequestError('Not found', {
           code: 'P2025',
-          clientVersion: 'client',
+          clientVersion: 'x',
         }),
       );
 
       await expect(
-        service.update('id-invalido', { isCorrect: true }),
+        service.update('invalid-id', { isCorrect: true }),
       ).rejects.toThrow();
     });
   });
 
   describe('remove', () => {
-    it('deve remover tentativa', async () => {
-      mockPrismaService.answerAttempt.delete.mockResolvedValue(mockAttempt);
+    it('deve remover tentativa existente', async () => {
+      prisma.answerAttempt.delete.mockResolvedValue(mockAttempt);
 
       const result = await service.remove(attemptId);
 
-      expect(mockPrismaService.answerAttempt.delete).toHaveBeenCalledWith(
-        expect.objectContaining({ where: { id: attemptId } }),
-      );
+      expect(prisma.answerAttempt.delete).toHaveBeenCalledWith({
+        where: { id: attemptId },
+      });
+
       expect(result).toEqual(mockAttempt);
     });
 
-    it('deve lançar erro NotFound para tentativa não existente', async () => {
-      mockPrismaService.answerAttempt.delete.mockRejectedValue(
+    it('deve lançar erro se tentativa não for encontrada', async () => {
+      prisma.answerAttempt.delete.mockRejectedValue(
         new Prisma.PrismaClientKnownRequestError('Not found', {
           code: 'P2025',
-          clientVersion: 'client',
+          clientVersion: 'x',
         }),
       );
 
-      await expect(service.remove('id-invalido')).rejects.toThrow();
+      await expect(service.remove('invalid-id')).rejects.toThrow();
     });
   });
 });
diff --git a/src/answer-attempts/answer-attempts.service.ts b/src/answer-attempts/answer-attempts.service.ts
index dca7995..13b354a 100644
--- a/src/answer-attempts/answer-attempts.service.ts
+++ b/src/answer-attempts/answer-attempts.service.ts
@@ -1,20 +1,15 @@
 import { Injectable } from '@nestjs/common';
 import { PrismaService } from '../prisma/prisma.service';
-import { CreateAnswerAttemptDto } from './answer-attempts.dto';
-
-export type Filters = {
-  userId?: string;
-  questionId?: string;
-  isCorrect?: string;
-  limit?: string;
-  offset?: string;
-};
+import {
+  AttemptFilterDto,
+  CreateAnswerAttemptDto,
+} from './answer-attempts.dto';
 
 @Injectable()
 export class AnswerAttemptsService {
   constructor(private prisma: PrismaService) {}
 
-  async findAll(filters: Filters) {
+  async findAll(filters: AttemptFilterDto) {
     const where = {
       answer: {
         ...(filters.userId ? { userId: filters.userId } : {}),
@@ -28,8 +23,8 @@ export class AnswerAttemptsService {
     return this.prisma.answerAttempt.findMany({
       where,
       include: { answer: true },
-      take: filters.limit ? parseInt(filters.limit) : undefined,
-      skip: filters.offset ? parseInt(filters.offset) : undefined,
+      take: filters.limit,
+      skip: filters.offset,
       orderBy: { attemptAt: 'desc' },
     });
   }
diff --git a/src/answer-attempts/sadasd.json b/src/answer-attempts/sadasd.json
deleted file mode 100644
index 8a1f6f2..0000000
--- a/src/answer-attempts/sadasd.json
+++ /dev/null
@@ -1,2 +0,0 @@
-{"include": {"answer": true}, "orderBy": {"attemptAt": "desc"}, "skip": 0, "take": 5, "where": {"isCorrect": "true", "questionId": "question-id", "userId": "c0ef2121-dc9d-41b6-a90b-d683e047a28e"}}
-{"include": {"answer": true}, "orderBy": {"attemptAt": "desc"}, "skip": 0, "take": 5, "where": {"answer": {"questionId": "question-id", "userId": "c0ef2121-dc9d-41b6-a90b-d683e047a28e"}, "isCorrect": true}}
diff --git a/src/answers/answers.controller.spec.ts b/src/answers/answers.controller.spec.ts
index 83093b2..9dee876 100644
--- a/src/answers/answers.controller.spec.ts
+++ b/src/answers/answers.controller.spec.ts
@@ -1,5 +1,4 @@
 import { Test, TestingModule } from '@nestjs/testing';
-
 import { ForbiddenException, BadRequestException } from '@nestjs/common';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from 'src/common/interfaces/authenticated-request.interface';
@@ -8,21 +7,10 @@ import { AnswersController } from './answers.controller';
 
 describe('AnswersController', () => {
   let controller: AnswersController;
-  let answersService: AnswersService;
 
   const mockAnswersService = {
     create: jest.fn(),
   };
-
-  const validDto = {
-    userId: randomUUID(),
-    questionId: randomUUID(),
-    selectedOption: 'A',
-    textAnswer: 'Texto de exemplo',
-    isCorrect: true,
-    timeSpentSeconds: 45,
-  };
-
   const makeMockRequest = (role: string, sub: string): AuthenticatedRequest =>
     ({
       user: {
@@ -43,88 +31,87 @@ describe('AnswersController', () => {
     }).compile();
 
     controller = module.get<AnswersController>(AnswersController);
-    answersService = module.get<AnswersService>(AnswersService);
   });
 
   afterEach(() => {
     jest.clearAllMocks();
   });
 
-  describe("create", () => {
+  describe('create', () => {
     const newAnswerDto = {
       userId: randomUUID(),
       questionId: randomUUID(),
-      selectedOption: "A",
-      textAnswer: "Texto de exemplo",
+      selectedOption: 'A',
+      textAnswer: 'Texto de exemplo',
       isCorrect: true,
       timeSpentSeconds: 45,
     };
 
-    it("deve lançar erro 400 se DTO for inválido", async () => {
+    it('deve lançar erro 400 se DTO for inválido', async () => {
       const invalidDto = {
         ...newAnswerDto,
-        userId: "not-a-uuid",
+        userId: 'not-a-uuid',
       };
 
-      const req = makeMockRequest("ADMIN", randomUUID());
+      const req = makeMockRequest('ADMIN', randomUUID());
 
       await expect(controller.create(invalidDto, req)).rejects.toThrow(
         BadRequestException,
       );
     });
 
-    it("deve criar uma resposta como ADMIN para qualquer usuário", async () => {
-      const req = makeMockRequest("ADMIN", randomUUID());
+    it('deve criar uma resposta como ADMIN para qualquer usuário', async () => {
+      const req = makeMockRequest('ADMIN', randomUUID());
       mockAnswersService.create.mockResolvedValue({
-        id: "resposta-id",
+        id: 'resposta-id',
         ...newAnswerDto,
       });
 
       const result = await controller.create(newAnswerDto, req);
 
       expect(result).toMatchObject({
-        id: "resposta-id",
+        id: 'resposta-id',
         userId: newAnswerDto.userId,
       });
       expect(mockAnswersService.create).toHaveBeenCalledWith(newAnswerDto);
     });
 
-    it("deve criar uma resposta como STUDENT para si mesmo", async () => {
-      const req = makeMockRequest("STUDENT", newAnswerDto.userId);
+    it('deve criar uma resposta como STUDENT para si mesmo', async () => {
+      const req = makeMockRequest('STUDENT', newAnswerDto.userId);
       mockAnswersService.create.mockResolvedValue({
-        id: "resposta-id",
+        id: 'resposta-id',
         ...newAnswerDto,
       });
 
       const result = await controller.create(newAnswerDto, req);
 
-      expect(result).toHaveProperty("id", "resposta-id");
+      expect(result).toHaveProperty('id', 'resposta-id');
       expect(mockAnswersService.create).toHaveBeenCalledWith(newAnswerDto);
     });
 
-    it("deve lançar erro 403 se STUDENT tentar responder por outro usuário", async () => {
+    it('deve lançar erro 403 se STUDENT tentar responder por outro usuário', async () => {
       const anotherUserId = randomUUID();
-      const req = makeMockRequest("STUDENT", anotherUserId);
+      const req = makeMockRequest('STUDENT', anotherUserId);
 
       await expect(controller.create(newAnswerDto, req)).rejects.toThrow(
         ForbiddenException,
       );
     });
 
-    it("deve lançar erro 400 se DTO for inválido", async () => {
+    it('deve lançar erro 400 se DTO for inválido', async () => {
       const invalidDto = {
         ...newAnswerDto,
-        userId: "not-a-uuid",
+        userId: 'not-a-uuid',
       };
 
-      const req = makeMockRequest("ADMIN", randomUUID());
+      const req = makeMockRequest('ADMIN', randomUUID());
 
       await expect(controller.create(invalidDto, req)).rejects.toThrow(
         BadRequestException,
       );
     });
 
-    it("deve lançar erro 403 se não autenticado", async () => {
+    it('deve lançar erro 403 se não autenticado', async () => {
       const req = { user: null } as unknown as AuthenticatedRequest;
 
       await expect(controller.create(newAnswerDto, req)).rejects.toThrow(
@@ -132,6 +119,4 @@ describe('AnswersController', () => {
       );
     });
   });
-
 });
-
diff --git a/src/answers/answers.dto.ts b/src/answers/answers.dto.ts
index 25ca30a..27d588c 100644
--- a/src/answers/answers.dto.ts
+++ b/src/answers/answers.dto.ts
@@ -1,8 +1,37 @@
+import {
+  IsString,
+  IsUUID,
+  IsOptional,
+  IsBoolean,
+  IsInt,
+  Min,
+  ValidateIf,
+  IsNotEmpty,
+} from 'class-validator';
+
 export class CreateAnswerDto {
-  userId: string;
-  questionId: string;
+  @IsUUID('4', { message: 'O ID do usuário deve ser um UUID válido.' })
+  userId!: string;
+
+  @IsUUID('4', { message: 'O ID da pergunta deve ser um UUID válido.' })
+  questionId!: string;
+
+  @IsOptional()
+  @IsString({ message: 'A opção selecionada deve ser uma string.' })
+  @IsNotEmpty({ message: 'A opção selecionada não pode ser uma string vazia.' })
   selectedOption?: string;
+
+  @IsOptional()
+  @IsString({ message: 'A resposta em texto deve ser uma string.' })
+  @ValidateIf((o: CreateAnswerDto) => o.textAnswer !== null)
   textAnswer?: string | null;
+
+  @IsOptional()
+  @IsBoolean({ message: 'O campo "isCorrect" deve ser booleano.' })
   isCorrect?: boolean;
+
+  @IsOptional()
+  @IsInt({ message: 'O tempo gasto deve ser um número inteiro.' })
+  @Min(0, { message: 'O tempo gasto não pode ser negativo.' })
   timeSpentSeconds?: number;
 }
diff --git a/src/answers/answers.service.spec.ts b/src/answers/answers.service.spec.ts
index 2d6cf62..54712f2 100644
--- a/src/answers/answers.service.spec.ts
+++ b/src/answers/answers.service.spec.ts
@@ -1,19 +1,99 @@
 import { Test, TestingModule } from '@nestjs/testing';
-import { AnswersService } from './answers.service';
 import { PrismaService } from '../prisma/prisma.service';
+import { AnswersService } from './answers.service';
+import { randomUUID } from 'crypto';
+import { CreateAnswerDto } from './answers.dto';
 
 describe('AnswersService', () => {
   let service: AnswersService;
 
+  const mockPrisma: {
+    answer: {
+      create: jest.Mock;
+      findUnique: jest.Mock;
+      update: jest.Mock;
+      delete: jest.Mock;
+      findMany: jest.Mock;
+    };
+  } = {
+    answer: {
+      create: jest.fn(),
+      findUnique: jest.fn(),
+      update: jest.fn(),
+      delete: jest.fn(),
+      findMany: jest.fn(),
+    },
+  };
+
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
-      providers: [AnswersService, PrismaService],
+      providers: [
+        AnswersService,
+        {
+          provide: PrismaService,
+          useValue: mockPrisma, // Injeta o mock do PrismaService
+        },
+      ],
     }).compile();
 
     service = module.get<AnswersService>(AnswersService);
+    jest.clearAllMocks(); // Limpa todos os mocks para garantir que os testes sejam independentes
   });
 
-  it('should be defined', () => {
-    expect(service).toBeDefined();
+  describe('create', () => {
+    it('should create answer', async () => {
+      const data: CreateAnswerDto = {
+        userId: randomUUID(),
+        questionId: randomUUID(),
+        selectedOption: 'A',
+      };
+
+      const createdAnswer = { id: randomUUID(), ...data };
+      mockPrisma.answer.create.mockResolvedValue(createdAnswer); // Mocka o retorno da criação
+
+      const result = await service.create(data); // Chama o método que deve usar o Prisma
+
+      // Verifica se a função create do Prisma foi chamada corretamente
+      expect(mockPrisma.answer.create).toHaveBeenCalledWith({ data });
+      expect(result).toEqual(createdAnswer); // Verifica se o retorno está correto
+    });
+
+    it('should throw if prisma.create fails', async () => {
+      mockPrisma.answer.create.mockRejectedValue(
+        new Error('Prisma create error'),
+      ); // Mocka falha
+
+      // Verifica se o erro é lançado corretamente quando o Prisma falha
+      await expect(
+        service.create({
+          userId: 'x',
+          questionId: 'y',
+          selectedOption: 'A',
+        }),
+      ).rejects.toThrow('Prisma create error');
+    });
+  });
+
+  describe('findOne', () => {
+    it('should return answer by id', async () => {
+      const id = 'answer-id';
+      const answer = { id, userId: 'uuid', questionId: 'uuid' };
+      mockPrisma.answer.findUnique.mockResolvedValue(answer); // Mocka a busca no Prisma
+
+      const result = await service.findOne(id); // Chama o método que deve usar o Prisma
+
+      expect(mockPrisma.answer.findUnique).toHaveBeenCalledWith({
+        where: { id },
+      });
+      expect(result).toEqual(answer); // Verifica se o retorno está correto
+    });
+
+    it('should return null if not found', async () => {
+      mockPrisma.answer.findUnique.mockResolvedValue(null); // Mocka a não existência da resposta
+
+      const result = await service.findOne('not-exist'); // Chama com id inexistente
+
+      expect(result).toBeNull(); // Verifica se o resultado é null
+    });
   });
 });
diff --git a/src/answers/answers.service.ts b/src/answers/answers.service.ts
index 9e7fb05..3f5fce1 100644
--- a/src/answers/answers.service.ts
+++ b/src/answers/answers.service.ts
@@ -1,11 +1,15 @@
 import { Injectable } from '@nestjs/common';
 import { PrismaService } from '../prisma/prisma.service';
+import { CreateAnswerDto } from './answers.dto';
 
 @Injectable()
 export class AnswersService {
   constructor(private prisma: PrismaService) {}
+  async findOne(id: string) {
+    return this.prisma.answer.findUnique({ where: { id } });
+  }
 
-  async create(data: any) {
+  async create(data: CreateAnswerDto) {
     return this.prisma.answer.create({
       data: {
         userId: data.userId,
diff --git a/src/common/dto/filters.dto.ts b/src/common/dto/filters.dto.ts
new file mode 100644
index 0000000..927fcad
--- /dev/null
+++ b/src/common/dto/filters.dto.ts
@@ -0,0 +1,21 @@
+import { IsOptional, IsUUID, IsInt, Min } from 'class-validator';
+
+export class FindQuestionsFiltersDto {
+  @IsOptional()
+  @IsUUID('4') // Garante que o userId seja um UUID válido
+  userId?: string;
+
+  @IsOptional()
+  @IsUUID('4') // Garante que o questionId seja um UUID válido
+  questionId?: string;
+
+  @IsOptional()
+  @IsInt() // Garante que o limit seja um número inteiro
+  @Min(1) // Garante que o limit seja maior ou igual a 1
+  limit?: number;
+
+  @IsOptional()
+  @IsInt() // Garante que o offset seja um número inteiro
+  @Min(0) // Garante que o offset seja maior ou igual a 0
+  offset?: number;
+}
diff --git a/src/common/interfaces/authenticated-request.interface.ts b/src/common/interfaces/authenticated-request.interface.ts
index e545de7..485077c 100644
--- a/src/common/interfaces/authenticated-request.interface.ts
+++ b/src/common/interfaces/authenticated-request.interface.ts
@@ -7,11 +7,3 @@ export interface AuthenticatedRequest extends Request {
     role: UserRole;
   };
 }
-
-// Versão mock: apenas `user.sub` e `user.role`
-export interface AuthenticatedRequestMock {
-  user: {
-    sub: string;
-    role: UserRole;
-  };
-}
diff --git a/src/courses/courses.controller.spec.ts b/src/courses/courses.controller.spec.ts
index e432d2b..dfdc9a4 100644
--- a/src/courses/courses.controller.spec.ts
+++ b/src/courses/courses.controller.spec.ts
@@ -1,24 +1,32 @@
+import { adminReq, professorId, studentReq } from '../__mocks__/user_mocks'; // Assumindo mocks de requisições autenticadas
 import { Test, TestingModule } from '@nestjs/testing';
 import { CoursesController } from './courses.controller';
 import { CoursesService } from './courses.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
-import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+  ValidationPipe,
+} from '@nestjs/common';
+import { AuthenticatedRequest } from 'src/common/interfaces/authenticated-request.interface';
+import { CreateCourseDto, IdParamDto } from './courses.dto';
 
 describe('CoursesController', () => {
   let controller: CoursesController;
   let service: CoursesService;
 
   const mockCourseId = randomUUID();
-  const mockAdminId = randomUUID();
-  const mockStudentId = randomUUID();
 
   const mockCourse = {
     id: mockCourseId,
     title: 'Test Course',
     description: 'This is a test course',
-    authorId: randomUUID(),
+    instructorId: professorId,
+    thumbnail: null,
+    price: null,
+    isPublished: false,
   };
 
   const mockPrismaService = {
@@ -31,20 +39,6 @@ describe('CoursesController', () => {
     },
   };
 
-  const mockAuthenticatedAdminRequest: AuthenticatedRequest = {
-    user: {
-      sub: mockAdminId,
-      role: 'ADMIN',
-    },
-  } as AuthenticatedRequest;
-
-  const mockAuthenticatedStudentRequest: AuthenticatedRequest = {
-    user: {
-      sub: mockStudentId,
-      role: 'STUDENT',
-    },
-  } as AuthenticatedRequest;
-
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
       controllers: [CoursesController],
@@ -64,137 +58,203 @@ describe('CoursesController', () => {
 
   it('should be defined', () => {
     expect(controller).toBeDefined();
+    expect(service).toBeDefined();
   });
 
   describe('findAll', () => {
-    it('should return a list of courses for any authenticated user', async () => {
+    it('should return courses with filters for authenticated user', async () => {
       mockPrismaService.course.findMany.mockResolvedValue([mockCourse]);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest);
-
-      expect(result).toEqual([mockCourse]);
-      expect(mockPrismaService.course.findMany).toHaveBeenCalledTimes(1);
-    });
-
-    it('should return course by ID for any authenticated user', async () => {
-      mockPrismaService.course.findUnique.mockResolvedValue(mockCourse);
-
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockCourseId);
-
-      expect(result).toEqual(mockCourse);
-      expect(mockPrismaService.course.findUnique).toHaveBeenCalledWith({ where: { id: mockCourseId } });
-    });
-
-    it('should throw BadRequestException for invalid course ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
-    });
-
-    it('should throw NotFoundException when course not found', async () => {
-      mockPrismaService.course.findUnique.mockResolvedValue(null);
-
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
-    });
-
-    it('should apply filters when provided', async () => {
-      mockPrismaService.course.findMany.mockResolvedValue([]);
-
-      const filters = {
-        authorId: randomUUID(),
-        limit: '10',
-        offset: '0',
-      };
-
-      await controller.findAll(
-        mockAuthenticatedStudentRequest,
+      const result = await controller.findAll(
+        studentReq,
         undefined,
-        filters.authorId,
-        filters.limit,
-        filters.offset,
+        professorId,
+        '5',
+        '0',
       );
 
-      expect(mockPrismaService.course.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          authorId: filters.authorId,
+      expect(result).toEqual([mockCourse]);
+      expect(mockPrismaService.course.findMany).toHaveBeenCalledWith({
+        where: { instructorId: professorId },
+        include: {
+          modules: { include: { lessons: true } },
+          enrollments: true,
+          reviews: true,
         },
-        take: 10,
+        take: 5,
         skip: 0,
-      }));
+      });
+    });
+
+    it('should throw ForbiddenException if no user', async () => {
+      const fakeUser = {} as AuthenticatedRequest;
+      await expect(controller.findAll(fakeUser)).rejects.toThrow(
+        ForbiddenException,
+      );
     });
   });
 
   describe('create', () => {
-    const createCourseDto = {
+    const createDto: CreateCourseDto = {
       title: 'New Course',
-      description: 'Description of new course',
+      description: 'Description',
+      instructorId: professorId,
+      thumbnail: null,
+      price: 10,
+      isPublished: true,
     };
 
-    it('should create course for ADMIN', async () => {
-      const createdCourse = { id: randomUUID(), ...createCourseDto, authorId: mockAdminId };
-      mockPrismaService.course.create.mockResolvedValue(createdCourse);
+    it('should create course for ADMIN with valid data', async () => {
+      mockPrismaService.course.create.mockResolvedValue({
+        id: randomUUID(),
+        ...createDto,
+      });
 
-      const result = await controller.create(createCourseDto, mockAuthenticatedAdminRequest);
+      const result = await controller.create(createDto, adminReq);
 
-      expect(result).toEqual(createdCourse);
-      expect(mockPrismaService.course.create).toHaveBeenCalledWith({ data: { ...createCourseDto, authorId: mockAdminId } });
+      expect(result).toMatchObject(createDto);
+      expect(mockPrismaService.course.create).toHaveBeenCalledWith({
+        data: {
+          ...createDto,
+          instructor: { connect: { id: createDto.instructorId } },
+        },
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { ...createCourseDto, title: '' };
-      await expect(controller.create(invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid data', async () => {
+      const invalidDto = {
+        id: randomUUID(),
+        description: 1,
+        title: 2,
+        price: 'a',
+      };
+
+      // Transforma o objeto como o Nest faria
+      const pipe = new ValidationPipe({ transform: true });
+      try {
+        await pipe.transform(invalidDto, {
+          type: 'body',
+          metatype: CreateCourseDto,
+        });
+      } catch (err) {
+        expect(err).toBeInstanceOf(BadRequestException);
+        return;
+      }
+
+      // Se passou da validação, falha o teste
+      fail('ValidationPipe não lançou BadRequestException como esperado.');
     });
 
-    it("should throw ForbiddenException for STUDENT", async () => {
-      await expect(controller.create(createCourseDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+    it('should throw ForbiddenException if user not ADMIN or TEACHER', async () => {
+      await expect(controller.create(createDto, studentReq)).rejects.toThrow(
+        ForbiddenException,
+      );
+    });
+
+    it('should throw ForbiddenException if TEACHER tries to create course for another instructor', async () => {
+      const teacherReq = {
+        user: { sub: randomUUID(), role: 'TEACHER' },
+      } as AuthenticatedRequest;
+      const dtoWithOtherInstructor = {
+        ...createDto,
+        instructorId: professorId, // different from teacherReq.user.sub
+      };
+      await expect(
+        controller.create(dtoWithOtherInstructor, teacherReq),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
-  describe("update", () => {
-    const updateDto = { title: "Updated Course" };
+  describe('update', () => {
+    const updateDto = { title: 'Updated Title', description: 'Updated desc' };
 
-    it("should update course for ADMIN", async () => {
-      const updatedCourse = { ...mockCourse, ...updateDto };
+    it('should update course for ADMIN', async () => {
       mockPrismaService.course.findUnique.mockResolvedValue(mockCourse);
-      mockPrismaService.course.update.mockResolvedValue(updatedCourse);
+      mockPrismaService.course.update.mockResolvedValue({
+        ...mockCourse,
+        ...updateDto,
+      });
+
+      const result = await controller.update(
+        { id: mockCourseId },
+        updateDto,
+        adminReq,
+      );
+
+      expect(result).toMatchObject(updateDto);
+      expect(mockPrismaService.course.update).toHaveBeenCalledWith({
+        where: { id: mockCourseId },
+        data: updateDto,
+      });
+    });
 
-      const result = await controller.update(mockCourseId, updateDto, mockAuthenticatedAdminRequest);
+    it('should throw BadRequestException for invalid ID', async () => {
+      const pipe = new ValidationPipe({ transform: true });
 
-      expect(result).toEqual(updatedCourse);
-      expect(mockPrismaService.course.update).toHaveBeenCalledWith({ where: { id: mockCourseId }, data: updateDto });
+      const dto = new IdParamDto();
+      dto.id = 'invalid-uuid'; // Valor inválido
+
+      await expect(() =>
+        pipe.transform(dto, { type: 'param', metatype: IdParamDto }),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.update("invalid-id", updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw NotFoundException if course not found', async () => {
+      mockPrismaService.course.findUnique.mockResolvedValue(null);
+      await expect(
+        controller.update({ id: mockCourseId }, updateDto, adminReq),
+      ).rejects.toThrow(NotFoundException);
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { title: "" };
-      await expect(controller.update(mockCourseId, invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw ForbiddenException if user not authorized', async () => {
+      mockPrismaService.course.findUnique.mockResolvedValue(mockCourse);
+      const otherUserReq = {
+        user: { sub: 'other-id', role: 'TEACHER' },
+      } as AuthenticatedRequest;
+
+      await expect(
+        controller.update({ id: mockCourseId }, updateDto, otherUserReq),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
-  describe("remove", () => {
-    it("should delete course for ADMIN", async () => {
+  describe('remove', () => {
+    it('should delete course for ADMIN', async () => {
       mockPrismaService.course.findUnique.mockResolvedValue(mockCourse);
       mockPrismaService.course.delete.mockResolvedValue(mockCourse);
 
-      const result = await controller.remove(mockCourseId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove({ id: mockCourseId }, adminReq);
 
-      expect(result).toEqual({ message: "Course deleted" });
-      expect(mockPrismaService.course.delete).toHaveBeenCalledWith({ where: { id: mockCourseId } });
+      expect(result).toEqual({ message: 'Curso deletado com sucesso.' });
+      expect(mockPrismaService.course.delete).toHaveBeenCalledWith({
+        where: { id: mockCourseId },
+      });
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.remove({ id: 'invalid-uuid' }, adminReq),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw NotFoundException when course not found", async () => {
+    it('should throw NotFoundException if course not found', async () => {
       mockPrismaService.course.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove({ id: mockCourseId }, adminReq),
+      ).rejects.toThrow(NotFoundException);
     });
 
-    it("should throw ForbiddenException for STUDENT", async () => {
+    it('should throw ForbiddenException if user not authorized', async () => {
       mockPrismaService.course.findUnique.mockResolvedValue(mockCourse);
 
-      await expect(controller.update(mockCourseId, updateDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
-    });
\ No newline at end of file
+      const otherUserReq = {
+        user: { sub: 'other-id', role: 'TEACHER' },
+      } as AuthenticatedRequest;
+
+      await expect(
+        controller.remove({ id: mockCourseId }, otherUserReq),
+      ).rejects.toThrow(ForbiddenException);
+    });
+  });
+});
diff --git a/src/courses/courses.controller.ts b/src/courses/courses.controller.ts
index ee15dcf..3da2a17 100644
--- a/src/courses/courses.controller.ts
+++ b/src/courses/courses.controller.ts
@@ -9,148 +9,96 @@ import {
   UseGuards,
   Request,
   Query,
-  BadRequestException,
   ForbiddenException,
   NotFoundException,
+  BadRequestException,
 } from '@nestjs/common';
 import { CoursesService } from './courses.service';
 import { JwtAuthGuard } from '../auth/jwt-auth.guard/jwt-auth.guard';
 import { RolesGuard } from '../auth/roles.guard/roles.guard';
 import { Roles } from '../auth/roles.decorator/roles.decorator';
 import { UserRole } from '@prisma/client';
-import { z, ZodError } from 'zod';
 import { Prisma } from '@prisma/client';
-
-// Esquema de validação para criação e atualização de cursos
-const courseSchema = z.object({
-  title: z.string().min(1, 'O título é obrigatório.'),
-  description: z.string().min(1, 'A descrição é obrigatória.'),
-  instructorId: z.string().min(1, 'O ID do instrutor é obrigatório.'),
-  thumbnail: z.string().url('URL da thumbnail inválida.').optional().nullable(),
-  price: z
-    .number()
-    .positive('O preço deve ser um número positivo.')
-    .optional()
-    .nullable(),
-  isPublished: z.boolean().optional(),
-});
-
-// Esquema de validação para o ID (usado em PUT e DELETE)
-const idSchema = z.object({
-  id: z.string().uuid().min(1, 'O ID é obrigatório.'),
-});
+import { AuthenticatedRequest } from 'src/common/interfaces/authenticated-request.interface';
+import { CreateCourseDto, IdParamDto, UpdateCourseDto } from './courses.dto';
+import { isUUID } from 'class-validator';
 
 @Controller('courses')
 export class CoursesController {
   constructor(private readonly coursesService: CoursesService) {}
 
-  private handleZodError(error: ZodError) {
-    return error.errors.map((e) => ({
-      path: e.path.join('.'),
-      message: e.message,
-    }));
-  }
-
   @UseGuards(JwtAuthGuard)
   @Get()
   async findAll(
-    @Request() req: any,
+    @Request() req: AuthenticatedRequest,
     @Query('title') title?: string,
     @Query('instructorId') instructorId?: string,
     @Query('limit') limit?: string,
     @Query('offset') offset?: string,
   ) {
-    const token = req.user;
-
-    if (!token) {
+    if (!req.user) {
       throw new ForbiddenException('Não autenticado.');
     }
 
-    const filters = {
+    return this.coursesService.findAll({
       title,
       instructorId,
       limit,
       offset,
-    };
-
-    return this.coursesService.findAll(filters);
+    });
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.TEACHER, UserRole.ADMIN)
   @Post()
-  async create(@Body() createCourseDto: any, @Request() req: any) {
-    const token = req.user;
-
-    const parsedBody = courseSchema.safeParse(createCourseDto);
-
-    if (!parsedBody.success) {
-      throw new BadRequestException({
-        message: 'Dados inválidos',
-        errors: this.handleZodError(parsedBody.error),
-      });
-    }
+  async create(
+    @Body() body: CreateCourseDto,
+    @Request() req: AuthenticatedRequest,
+  ) {
+    const user = req.user;
+    const data = body;
 
-    // O instrutor do curso deve ser o usuário logado, a menos que seja ADMIN
-    if (token.role !== 'ADMIN' && parsedBody.data.instructorId !== token.sub) {
+    if (user.role !== 'ADMIN' && data.instructorId !== user.sub) {
       throw new ForbiddenException(
         'Não autorizado a criar curso para outro instrutor.',
       );
     }
 
-    return this.coursesService.create(parsedBody.data);
+    return this.coursesService.create({
+      ...data,
+      instructor: { connect: { id: data.instructorId } },
+    });
   }
 
   @UseGuards(JwtAuthGuard)
   @Patch(':id')
   async update(
-    @Param('id') id: string,
-    @Body() updateCourseDto: any,
-    @Request() req: any,
+    @Param('id') params: IdParamDto,
+    @Body() body: UpdateCourseDto,
+    @Request() req: AuthenticatedRequest,
   ) {
-    const token = req.user;
+    const user = req.user;
 
-    if (!token) {
+    if (!user) {
       throw new ForbiddenException('Não autenticado.');
     }
 
-    const parsedId = idSchema.safeParse({ id });
-
-    if (!parsedId.success) {
-      throw new BadRequestException({
-        message: 'ID inválido ou ausente',
-        errors: this.handleZodError(parsedId.error),
-      });
-    }
-
-    const parsedCourseData = courseSchema.safeParse(updateCourseDto);
-
-    if (!parsedCourseData.success) {
-      throw new BadRequestException({
-        message: 'Dados inválidos para atualização',
-        errors: this.handleZodError(parsedCourseData.error),
-      });
-    }
-
-    const existingCourse = await this.coursesService.findOne(parsedId.data.id);
+    const data = body;
 
+    const existingCourse = await this.coursesService.findOne(params.id);
     if (!existingCourse) {
       throw new NotFoundException('Curso não encontrado para atualização.');
     }
 
-    // Apenas PROFESSOR e ADMIN podem atualizar cursos, ou o instrutor do curso
     if (
-      token.role !== 'ADMIN' &&
-      !(token.role === 'PROFESSOR' && token.sub === existingCourse.instructorId)
+      user.role !== 'ADMIN' &&
+      !(user.role === 'TEACHER' && user.sub === existingCourse.instructorId)
     ) {
-      throw new ForbiddenException('Não autorizado.');
+      throw new ForbiddenException('Não autorizado a editar este curso.');
     }
 
     try {
-      return await this.coursesService.update(
-        parsedId.data.id,
-        parsedCourseData.data,
-      );
+      return await this.coursesService.update(params.id, data);
     } catch (error) {
       if (
         error instanceof Prisma.PrismaClientKnownRequestError &&
@@ -164,35 +112,31 @@ export class CoursesController {
 
   @UseGuards(JwtAuthGuard)
   @Delete(':id')
-  async remove(@Param('id') id: string, @Request() req: any) {
-    const token = req.user;
-
-    if (!token) {
-      throw new ForbiddenException('Não autenticado.');
+  async remove(
+    @Param('id') params: IdParamDto,
+    @Request() req: AuthenticatedRequest,
+  ) {
+    if (!isUUID(params.id)) {
+      throw new BadRequestException('ID inválido.');
     }
+    const user = req.user;
 
-    const parsedId = idSchema.safeParse({ id });
-
-    if (!parsedId.success) {
-      throw new BadRequestException({
-        message: 'ID inválido ou ausente',
-        errors: this.handleZodError(parsedId.error),
-      });
+    if (!user) {
+      throw new ForbiddenException('Não autenticado.');
     }
 
-    const existingCourse = await this.coursesService.findOne(parsedId.data.id);
+    const existingCourse = await this.coursesService.findOne(params.id);
 
     if (!existingCourse) {
       throw new NotFoundException('Curso não encontrado para exclusão.');
     }
 
-    // Apenas ADMIN pode deletar cursos, ou o instrutor do curso
-    if (token.role !== 'ADMIN' && token.sub !== existingCourse.instructorId) {
-      throw new ForbiddenException('Não autorizado.');
+    if (user.role !== 'ADMIN' && user.sub !== existingCourse.instructorId) {
+      throw new ForbiddenException('Não autorizado a excluir este curso.');
     }
 
     try {
-      await this.coursesService.remove(parsedId.data.id);
+      await this.coursesService.remove(params.id);
       return { message: 'Curso deletado com sucesso.' };
     } catch (error) {
       if (
diff --git a/src/courses/courses.dto.ts b/src/courses/courses.dto.ts
new file mode 100644
index 0000000..3a66fa2
--- /dev/null
+++ b/src/courses/courses.dto.ts
@@ -0,0 +1,41 @@
+import { PartialType } from '@nestjs/mapped-types';
+import {
+  IsString,
+  IsOptional,
+  IsUrl,
+  IsUUID,
+  IsBoolean,
+  IsNumber,
+  Min,
+} from 'class-validator';
+
+export class CreateCourseDto {
+  @IsString({ message: 'O título é obrigatório.' })
+  title!: string;
+
+  @IsString({ message: 'A descrição é obrigatória.' })
+  description!: string;
+
+  @IsUUID('4', { message: 'O ID do instrutor deve ser um UUID válido.' })
+  instructorId!: string;
+
+  @IsOptional()
+  @IsUrl({}, { message: 'URL da thumbnail inválida.' })
+  thumbnail?: string | null;
+
+  @IsOptional()
+  @IsNumber({}, { message: 'O preço deve ser um número.' })
+  @Min(0, { message: 'O preço deve ser um número positivo.' })
+  price?: number | null;
+
+  @IsOptional()
+  @IsBoolean({ message: 'O campo "isPublished" deve ser um booleano.' })
+  isPublished?: boolean;
+}
+
+export class UpdateCourseDto extends PartialType(CreateCourseDto) {}
+
+export class IdParamDto {
+  @IsUUID('4', { message: 'O ID deve ser um UUID válido.' })
+  id!: string;
+}
diff --git a/src/courses/courses.service.spec.ts b/src/courses/courses.service.spec.ts
index e5bba54..70cef9b 100644
--- a/src/courses/courses.service.spec.ts
+++ b/src/courses/courses.service.spec.ts
@@ -1,21 +1,140 @@
+/* eslint-disable @typescript-eslint/unbound-method */
 import { Test, TestingModule } from '@nestjs/testing';
 import { CoursesService } from './courses.service';
 import { PrismaService } from '../prisma/prisma.service';
+import { Course } from '@prisma/client';
+import { mockDeep, DeepMockProxy } from 'jest-mock-extended';
 
 describe('CoursesService', () => {
   let service: CoursesService;
-  let prismaService: PrismaService;
+  let prismaService: DeepMockProxy<PrismaService>;
 
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
-      providers: [CoursesService, PrismaService],
+      providers: [
+        CoursesService,
+        {
+          provide: PrismaService,
+          useValue: mockDeep<PrismaService>(),
+        },
+      ],
     }).compile();
 
     service = module.get<CoursesService>(CoursesService);
-    prismaService = module.get<PrismaService>(PrismaService);
+    prismaService = module.get(PrismaService);
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
   });
 
   it('should be defined', () => {
     expect(service).toBeDefined();
   });
+
+  describe('findAll', () => {
+    it('should call prisma.course.findMany with correct filters', async () => {
+      const mockCourses: Course[] = [
+        { id: '1', title: 'Test', instructorId: 'abc' } as Course,
+      ];
+
+      prismaService.course.findMany.mockResolvedValue(mockCourses);
+
+      const result = await service.findAll({
+        title: 'Test',
+        instructorId: 'abc',
+        limit: '10',
+        offset: '0',
+      });
+
+      expect(prismaService.course.findMany).toHaveBeenCalledWith({
+        where: {
+          title: { contains: 'Test', mode: 'insensitive' },
+          instructorId: 'abc',
+        },
+        take: 10,
+        skip: 0,
+        include: {
+          modules: {
+            include: {
+              lessons: true,
+            },
+          },
+          enrollments: true,
+          reviews: true,
+        },
+      });
+
+      expect(result).toEqual(mockCourses);
+    });
+  });
+
+  // Faça o mesmo para os outros métodos: findOne, create, update, remove
+
+  describe('findOne', () => {
+    it('should call prisma.course.findUnique with correct id', async () => {
+      const mockCourse = { id: '1', instructorId: 'abc' };
+      prismaService.course.findUnique.mockResolvedValue(mockCourse as any);
+
+      const result = await service.findOne('1');
+
+      expect(prismaService.course.findUnique).toHaveBeenCalledWith({
+        where: { id: '1' },
+        select: {
+          id: true,
+          instructorId: true,
+        },
+      });
+      expect(result).toEqual(mockCourse);
+    });
+  });
+
+  describe('create', () => {
+    it('should call prisma.course.create with correct data', async () => {
+      const newCourse = {
+        title: 'Test Course',
+        description: 'A course',
+        instructor: { connect: { id: 'abc' } },
+      };
+
+      const createdCourse = { ...newCourse, id: '1' };
+      prismaService.course.create.mockResolvedValue(createdCourse as any);
+
+      const result = await service.create(newCourse as any);
+
+      expect(prismaService.course.create).toHaveBeenCalledWith({
+        data: newCourse,
+      });
+      expect(result).toEqual(createdCourse);
+    });
+  });
+
+  describe('update', () => {
+    it('should call prisma.course.update with correct id and data', async () => {
+      const updatedCourse = { id: '1', title: 'Updated', instructorId: 'abc' };
+      prismaService.course.update.mockResolvedValue(updatedCourse as any);
+
+      const result = await service.update('1', { title: 'Updated' });
+
+      expect(prismaService.course.update).toHaveBeenCalledWith({
+        where: { id: '1' },
+        data: { title: 'Updated' },
+      });
+      expect(result).toEqual(updatedCourse);
+    });
+  });
+
+  describe('remove', () => {
+    it('should call prisma.course.delete with correct id', async () => {
+      const deletedCourse = { id: '1', title: 'Deleted', instructorId: 'abc' };
+      prismaService.course.delete.mockResolvedValue(deletedCourse as any);
+
+      const result = await service.remove('1');
+
+      expect(prismaService.course.delete).toHaveBeenCalledWith({
+        where: { id: '1' },
+      });
+      expect(result).toEqual(deletedCourse);
+    });
+  });
 });
diff --git a/src/courses/courses.service.ts b/src/courses/courses.service.ts
index 2d13963..93e1ba0 100644
--- a/src/courses/courses.service.ts
+++ b/src/courses/courses.service.ts
@@ -1,49 +1,73 @@
 import { Injectable } from '@nestjs/common';
 import { PrismaService } from '../prisma/prisma.service';
+import { Prisma, Course } from '@prisma/client';
+
+interface FindAllFilters {
+  title?: string;
+  instructorId?: string;
+  limit?: string;
+  offset?: string;
+}
 
 @Injectable()
 export class CoursesService {
-  constructor(private prisma: PrismaService) {}
+  constructor(private readonly prisma: PrismaService) {}
+
+  async findAll(filters: FindAllFilters): Promise<Course[]> {
+    const { title, instructorId, limit, offset } = filters;
+
+    const take = limit && !isNaN(Number(limit)) ? parseInt(limit) : undefined;
+    const skip =
+      offset && !isNaN(Number(offset)) ? parseInt(offset) : undefined;
 
-  async findAll(filters: any) {
     return this.prisma.course.findMany({
       where: {
-        ...(filters.title && {
-          title: { contains: filters.title, mode: 'insensitive' },
+        ...(title && {
+          title: {
+            contains: title,
+            mode: 'insensitive',
+          },
         }),
-        ...(filters.instructorId && { instructorId: filters.instructorId }),
+        ...(instructorId && { instructorId }),
       },
       include: {
-        modules: { include: { lessons: true } },
+        modules: {
+          include: {
+            lessons: true,
+          },
+        },
         enrollments: true,
         reviews: true,
       },
-      take: filters.limit ? parseInt(filters.limit) : undefined,
-      skip: filters.offset ? parseInt(filters.offset) : undefined,
+      take,
+      skip,
     });
   }
 
-  async findOne(id: string) {
+  async findOne(
+    id: string,
+  ): Promise<Pick<Course, 'id' | 'instructorId'> | null> {
     return this.prisma.course.findUnique({
       where: { id },
-      select: { instructorId: true, id: true },
+      select: {
+        id: true,
+        instructorId: true,
+      },
     });
   }
 
-  async create(data: any) {
-    return this.prisma.course.create({
-      data,
-    });
+  async create(data: Prisma.CourseCreateInput): Promise<Course> {
+    return this.prisma.course.create({ data });
   }
 
-  async update(id: string, data: any) {
+  async update(id: string, data: Prisma.CourseUpdateInput): Promise<Course> {
     return this.prisma.course.update({
       where: { id },
       data,
     });
   }
 
-  async remove(id: string) {
+  async remove(id: string): Promise<Course> {
     return this.prisma.course.delete({
       where: { id },
     });
diff --git a/src/enrollments/enrollments.controller.spec.ts b/src/enrollments/enrollments.controller.spec.ts
index 4b29933..86febf4 100644
--- a/src/enrollments/enrollments.controller.spec.ts
+++ b/src/enrollments/enrollments.controller.spec.ts
@@ -1,12 +1,11 @@
+import { adminReq, studentReq } from '../__mocks__/user_mocks';
 import { Test, TestingModule } from '@nestjs/testing';
 import { EnrollmentsController } from './enrollments.controller';
 import { EnrollmentsService } from './enrollments.service';
-import { PrismaService } from '../prisma/prisma.service';
+import { CreateEnrollmentDto, UpdateEnrollmentDto } from './enrollments.dto';
 import { randomUUID } from 'crypto';
-import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
-import { Prisma } from '@prisma/client';
-
+import { EnrollmentStatus } from '@prisma/client';
+import { ForbiddenException, NotFoundException } from '@nestjs/common';
 describe('EnrollmentsController', () => {
   let controller: EnrollmentsController;
   let service: EnrollmentsService;
@@ -14,156 +13,189 @@ describe('EnrollmentsController', () => {
   const mockEnrollmentId = randomUUID();
   const mockUserId = randomUUID();
   const mockCourseId = randomUUID();
-  const mockAdminId = randomUUID();
 
   const mockEnrollment = {
     id: mockEnrollmentId,
     userId: mockUserId,
     courseId: mockCourseId,
-    enrollmentDate: new Date(),
-    status: 'ACTIVE',
+    enrolledAt: new Date(),
+    status: EnrollmentStatus.ACTIVE,
   };
 
-  const mockPrismaService = {
-    enrollment: {
-      findMany: jest.fn(),
-      findUnique: jest.fn(),
-      create: jest.fn(),
-      update: jest.fn(),
-      delete: jest.fn(),
-    },
-    user: {
-      findUnique: jest.fn(),
-    },
-    course: {
-      findUnique: jest.fn(),
-    },
+  const mockService = {
+    create: jest.fn(),
+    findAll: jest.fn(),
+    findManyByUserId: jest.fn(),
+    findOne: jest.fn(),
+    update: jest.fn(),
+    remove: jest.fn(),
   };
 
-  const mockAuthenticatedAdminRequest: AuthenticatedRequest = {
-    user: {
-      sub: mockAdminId,
-      role: 'ADMIN',
-    },
-  } as AuthenticatedRequest;
-
-  const mockAuthenticatedStudentRequest: AuthenticatedRequest = {
-    user: {
-      sub: mockUserId,
-      role: 'STUDENT',
-    },
-  } as AuthenticatedRequest;
-
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
       controllers: [EnrollmentsController],
       providers: [
-        EnrollmentsService,
-        { provide: PrismaService, useValue: mockPrismaService },
+        {
+          provide: EnrollmentsService,
+          useValue: mockService,
+        },
       ],
     }).compile();
 
     controller = module.get<EnrollmentsController>(EnrollmentsController);
     service = module.get<EnrollmentsService>(EnrollmentsService);
-  });
 
-  afterEach(() => {
     jest.clearAllMocks();
   });
 
   it('should be defined', () => {
     expect(controller).toBeDefined();
+    expect(service).toBeDefined();
   });
 
-  describe('findAll', () => {
-    it('should return a list of enrollments for ADMIN', async () => {
-      mockPrismaService.enrollment.findMany.mockResolvedValue([mockEnrollment]);
+  describe('create', () => {
+    it('should allow ADMIN to create enrollment', async () => {
+      const dto: CreateEnrollmentDto = {
+        userId: mockUserId,
+        courseId: mockCourseId,
+        status: EnrollmentStatus.ACTIVE,
+      };
 
-      const result = await controller.findAll(mockAuthenticatedAdminRequest);
+      // Prisma espera esse formato para relacionamentos
+      const prismaCreateInput: CreateEnrollmentDto = {
+        userId: mockUserId,
+        courseId: mockCourseId,
+        status: dto.status,
+      };
 
-      expect(result).toEqual([mockEnrollment]);
-      expect(mockPrismaService.enrollment.findMany).toHaveBeenCalledTimes(1);
+      mockService.create.mockResolvedValue(mockEnrollment);
+
+      const result = await controller.create(dto, adminReq);
+
+      expect(result).toEqual(mockEnrollment);
+      expect(mockService.create).toHaveBeenCalledWith(prismaCreateInput);
     });
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { userId: "invalid-uuid", courseId: "invalid-uuid", status: "INVALID" as Prisma.EnumEnrollmentStatusNames };
-      const req = mockAuthenticatedAdminRequest;
 
-      await expect(controller.create(invalidDto, req)).rejects.toThrow(BadRequestException);
+    it('should throw ForbiddenException if non-ADMIN tries to create', async () => {
+      const dto: CreateEnrollmentDto = {
+        userId: mockUserId,
+        courseId: mockCourseId,
+      };
+
+      await expect(controller.create(dto, studentReq)).rejects.toThrow(
+        ForbiddenException,
+      );
+
+      expect(mockService.create).not.toHaveBeenCalled();
     });
+  });
 
-    it("should create enrollment for ADMIN", async () => {
-      mockPrismaService.enrollment.findUnique.mockResolvedValue(mockEnrollment);
+  describe('findAll', () => {
+    it('should return all enrollments for ADMIN', async () => {
+      mockService.findAll.mockResolvedValue([mockEnrollment]);
 
-      const result = await controller.findOne(mockEnrollmentId);
+      const result = await controller.findAll(adminReq);
 
-      expect(result).toEqual(mockEnrollment);
-      expect(mockPrismaService.enrollment.findUnique).toHaveBeenCalledWith({ where: { id: mockEnrollmentId } });
+      expect(result).toEqual([mockEnrollment]);
+      expect(mockService.findAll).toHaveBeenCalled();
     });
 
-    it('should return own enrollments for STUDENT', async () => {
-      mockPrismaService.enrollment.findMany.mockResolvedValue([mockEnrollment]);
+    it('should return only student enrollments for STUDENT', async () => {
+      mockService.findManyByUserId.mockResolvedValue([mockEnrollment]);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest);
+      const result = await controller.findAll(studentReq);
 
       expect(result).toEqual([mockEnrollment]);
-      expect(mockPrismaService.enrollment.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: mockUserId,
-        },
-      }));
+      expect(mockService.findManyByUserId).toHaveBeenCalledWith(
+        studentReq.user.sub,
+      );
     });
+  });
 
-    it('should return specific enrollment for STUDENT if it belongs to them', async () => {
-      mockPrismaService.enrollment.findUnique.mockResolvedValue(mockEnrollment);
+  describe('findOne', () => {
+    it('should return enrollment if user is ADMIN', async () => {
+      mockService.findOne.mockResolvedValue(mockEnrollment);
 
-      const result = await controller.findOne(mockEnrollmentId);
+      const result = await controller.findOne(mockEnrollmentId, adminReq);
 
       expect(result).toEqual(mockEnrollment);
-      expect(mockPrismaService.enrollment.findUnique).toHaveBeenCalledWith({ where: { id: mockEnrollmentId } });
+      expect(mockService.findOne).toHaveBeenCalledWith(mockEnrollmentId);
     });
 
-    it("should throw ForbiddenException for STUDENT accessing other user enrollment", async () => {
-      mockPrismaService.enrollment.findUnique.mockResolvedValue({ ...mockEnrollment, userId: randomUUID() });
+    it('should return enrollment if student owns it', async () => {
+      const mockEnrollment = {
+        id: randomUUID(),
+        userId: studentReq.user.sub, // ID do estudante que faz a requisição
+        courseId: mockCourseId,
+        enrolledAt: new Date(),
+      };
+
+      mockService.findOne.mockResolvedValue(mockEnrollment);
+
+      const result = await controller.findOne(mockEnrollment.id, studentReq);
 
-      await expect(controller.findOne(mockEnrollmentId)).rejects.toThrow(ForbiddenException);
+      expect(result).toEqual(mockEnrollment);
     });
 
-    it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.findOne("invalid-id")).rejects.toThrow(BadRequestException);
+    it('should throw ForbiddenException if student accesses another enrollment', async () => {
+      mockService.findOne.mockResolvedValue({
+        ...mockEnrollment,
+        userId: randomUUID(), // ID diferente para simular outro usuário
+      });
+
+      await expect(
+        controller.findOne(mockEnrollmentId, studentReq),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it('should throw NotFoundException when enrollment not found', async () => {
-      mockPrismaService.enrollment.findUnique.mockResolvedValue(null);
+    it('should throw NotFoundException if enrollment not found', async () => {
+      mockService.findOne.mockResolvedValue(null);
 
-      await expect(controller.findOne(randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findOne(mockEnrollmentId, adminReq),
+      ).rejects.toThrow(NotFoundException);
     });
+  });
+
+  describe('remove', () => {
+    it('should call service.remove for ADMIN', async () => {
+      mockService.remove.mockResolvedValue(true);
 
-    it('should apply filters when provided', async () => {
-      mockPrismaService.enrollment.findMany.mockResolvedValue([]);
+      await controller.remove(mockEnrollmentId);
 
-      const filters = {
-        userId: randomUUID(),
-        courseId: randomUUID(),
-        status: 'ACTIVE',
-        limit: '10',
-        offset: '0',
+      expect(mockService.remove).toHaveBeenCalledWith(mockEnrollmentId);
+    });
+  });
+
+  describe('update', () => {
+    it('should call service.update for ADMIN', async () => {
+      const updateDto: Partial<UpdateEnrollmentDto> = {
+        status: EnrollmentStatus.COMPLETED,
       };
 
-      await controller.findAll(
-        mockAuthenticatedAdminRequest,
-        filters.userId,
-        filters.courseId,
-        filters.status,
-        filters.limit,
-        filters.offset,
-      );
+      const updatedEnrollment = {
+        ...mockEnrollment,
+        status: EnrollmentStatus.COMPLETED,
+      };
 
-      expect(mockPrismaService.enrollment.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: filters.userId,
-          courseId: filters.courseId,
-          status: filters.status,
-        },
-        take: 10,
-        skip: 0,
-      }));
\ No newline at end of file
+      mockService.update.mockResolvedValue(updatedEnrollment);
+
+      const result = await controller.update(mockEnrollmentId, updateDto);
+
+      expect(result).toEqual(updatedEnrollment);
+      expect(mockService.update).toHaveBeenCalledWith(
+        mockEnrollmentId,
+        updateDto,
+      );
+    });
+    it('should throw NotFoundException when update fails', async () => {
+      mockService.update.mockResolvedValue(null);
+
+      await expect(
+        controller.update(mockEnrollmentId, {
+          status: EnrollmentStatus.CANCELLED,
+        }),
+      ).rejects.toThrow(NotFoundException);
+    });
+  });
+});
diff --git a/src/enrollments/enrollments.controller.ts b/src/enrollments/enrollments.controller.ts
index dbef40a..8948ab7 100644
--- a/src/enrollments/enrollments.controller.ts
+++ b/src/enrollments/enrollments.controller.ts
@@ -8,13 +8,17 @@ import {
   Delete,
   UseGuards,
   Request,
+  ForbiddenException,
+  NotFoundException,
+  ParseUUIDPipe,
 } from '@nestjs/common';
 import { EnrollmentsService } from './enrollments.service';
-import { Prisma } from '@prisma/client';
 import { JwtAuthGuard } from '../auth/jwt-auth.guard/jwt-auth.guard';
 import { RolesGuard } from '../auth/roles.guard/roles.guard';
 import { Roles } from '../auth/roles.decorator/roles.decorator';
-import { UserRole } from '@prisma/client';
+import { UserRole, EnrollmentStatus } from '@prisma/client';
+import { AuthenticatedRequest } from 'src/common/interfaces/authenticated-request.interface';
+import { CreateEnrollmentDto, UpdateEnrollmentDto } from './enrollments.dto';
 
 @Controller('enrollments')
 export class EnrollmentsController {
@@ -23,44 +27,87 @@ export class EnrollmentsController {
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN)
   @Post()
-  create(@Body() createEnrollmentDto: Prisma.EnrollmentCreateInput) {
-    return this.enrollmentsService.create(createEnrollmentDto);
+  async create(
+    @Body() createEnrollmentDto: CreateEnrollmentDto,
+    @Request() req: AuthenticatedRequest,
+  ) {
+    if (req.user.role !== UserRole.ADMIN) {
+      throw new ForbiddenException(
+        'No momento somente administradores podem criar inscrições',
+      );
+    }
+    console.log(
+      `Admin ${req.user.sub} criando matrícula para usuário ${createEnrollmentDto.userId}`,
+    );
+
+    const data = {
+      userId: createEnrollmentDto.userId,
+      courseId: createEnrollmentDto.courseId,
+      status: createEnrollmentDto.status || EnrollmentStatus.ACTIVE,
+    };
+    return this.enrollmentsService.create(data);
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN, UserRole.STUDENT)
   @Get()
-  findAll(@Request() req: any) {
+  async findAll(@Request() req: AuthenticatedRequest) {
     if (req.user.role === UserRole.ADMIN) {
       return this.enrollmentsService.findAll();
     } else if (req.user.role === UserRole.STUDENT) {
-      return this.enrollmentsService.findManyByUserId(req.user.userId);
-    } else {
-      return [];
+      return this.enrollmentsService.findManyByUserId(req.user.sub);
     }
+    return [];
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN, UserRole.STUDENT)
   @Get(':id')
-  findOne(@Param('id') id: string) {
-    return this.enrollmentsService.findOne(id);
+  async findOne(
+    @Param('id', ParseUUIDPipe) id: string,
+    @Request() req: AuthenticatedRequest,
+  ) {
+    const enrollment = await this.enrollmentsService.findOne(id);
+
+    if (!enrollment) {
+      throw new NotFoundException('Matrícula não encontrada');
+    }
+
+    if (
+      req.user.role === UserRole.STUDENT &&
+      enrollment.userId !== req.user.sub
+    ) {
+      throw new ForbiddenException('Acesso negado');
+    }
+
+    return enrollment;
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN)
   @Patch(':id')
-  update(
-    @Param('id') id: string,
-    @Body() updateEnrollmentDto: Prisma.EnrollmentUpdateInput,
+  async update(
+    @Param('id', ParseUUIDPipe) id: string,
+    @Body() updateEnrollmentDto: UpdateEnrollmentDto,
   ) {
-    return this.enrollmentsService.update(id, updateEnrollmentDto);
+    const updated = await this.enrollmentsService.update(
+      id,
+      updateEnrollmentDto,
+    );
+    if (!updated) {
+      throw new NotFoundException('Matrícula não encontrada');
+    }
+    return updated;
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN)
   @Delete(':id')
-  remove(@Param('id') id: string) {
-    return this.enrollmentsService.remove(id);
+  async remove(@Param('id', ParseUUIDPipe) id: string) {
+    const removed = await this.enrollmentsService.remove(id);
+    if (!removed) {
+      throw new NotFoundException('Matrícula não encontrada');
+    }
+    return removed;
   }
 }
diff --git a/src/enrollments/enrollments.dto.ts b/src/enrollments/enrollments.dto.ts
new file mode 100644
index 0000000..8b8dce2
--- /dev/null
+++ b/src/enrollments/enrollments.dto.ts
@@ -0,0 +1,28 @@
+import { EnrollmentStatus } from '@prisma/client';
+import { IsUUID, IsOptional, IsEnum } from 'class-validator';
+
+export class CreateEnrollmentDto {
+  @IsUUID()
+  userId!: string;
+
+  @IsUUID()
+  courseId!: string;
+
+  @IsOptional()
+  @IsEnum(EnrollmentStatus)
+  status?: EnrollmentStatus;
+}
+
+export class UpdateEnrollmentDto {
+  @IsOptional()
+  @IsUUID()
+  userId?: string;
+
+  @IsOptional()
+  @IsUUID()
+  courseId?: string;
+
+  @IsOptional()
+  @IsEnum(EnrollmentStatus)
+  status?: EnrollmentStatus;
+}
diff --git a/src/enrollments/enrollments.service.spec.ts b/src/enrollments/enrollments.service.spec.ts
index d253649..ae9fabf 100644
--- a/src/enrollments/enrollments.service.spec.ts
+++ b/src/enrollments/enrollments.service.spec.ts
@@ -17,5 +17,6 @@ describe('EnrollmentsService', () => {
 
   it('should be defined', () => {
     expect(service).toBeDefined();
+    expect(prismaService).toBeDefined();
   });
 });
diff --git a/src/enrollments/enrollments.service.ts b/src/enrollments/enrollments.service.ts
index e8e3dae..49b6d8c 100644
--- a/src/enrollments/enrollments.service.ts
+++ b/src/enrollments/enrollments.service.ts
@@ -1,12 +1,13 @@
 import { Injectable } from '@nestjs/common';
 import { PrismaService } from '../prisma/prisma.service';
 import { Prisma } from '@prisma/client';
+import { CreateEnrollmentDto } from './enrollments.dto';
 
 @Injectable()
 export class EnrollmentsService {
   constructor(private prisma: PrismaService) {}
 
-  async create(data: Prisma.EnrollmentCreateInput) {
+  async create(data: CreateEnrollmentDto) {
     return this.prisma.enrollment.create({ data });
   }
 
diff --git a/src/favorite-questions/favorite-questions.controller.spec.ts b/src/favorite-questions/favorite-questions.controller.spec.ts
index 8764f7b..2de8936 100644
--- a/src/favorite-questions/favorite-questions.controller.spec.ts
+++ b/src/favorite-questions/favorite-questions.controller.spec.ts
@@ -1,72 +1,74 @@
+/* eslint-disable @typescript-eslint/unbound-method */
 import { Test, TestingModule } from '@nestjs/testing';
+import { randomUUID } from 'crypto';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
+
 import { FavoriteQuestionsController } from './favorite-questions.controller';
 import { FavoriteQuestionsService } from './favorite-questions.service';
-import { PrismaService } from '../prisma/prisma.service';
-import { randomUUID } from 'crypto';
-import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+
+import { adminReq, studentReq } from '../__mocks__/user_mocks';
+import { mockDeep, DeepMockProxy } from 'jest-mock-extended';
+import { Difficulty, QuestionType, UserRole } from '@prisma/client';
 
 describe('FavoriteQuestionsController', () => {
   let controller: FavoriteQuestionsController;
-  let service: FavoriteQuestionsService;
+  let favoriteQuestionsService: DeepMockProxy<FavoriteQuestionsService>;
 
-  const mockFavoriteQuestionId = randomUUID();
-  const mockUserId = randomUUID();
   const mockQuestionId = randomUUID();
-  const mockAdminId = randomUUID();
-  const mockStudentId = randomUUID();
 
   const mockFavoriteQuestion = {
-    id: mockFavoriteQuestionId,
-    userId: mockUserId,
+    userId: studentReq.user.sub,
     questionId: mockQuestionId,
-    createdAt: new Date(),
+    markedAt: new Date('2025-07-04T12:00:00Z'),
   };
 
-  const mockPrismaService = {
-    favoriteQuestion: {
-      findMany: jest.fn(),
-      findUnique: jest.fn(),
-      create: jest.fn(),
-      delete: jest.fn(),
-    },
-    user: {
-      findUnique: jest.fn(),
-    },
-    question: {
-      findUnique: jest.fn(),
-    },
+  const mockQuestion = {
+    id: mockQuestionId,
+    createdAt: new Date('2025-07-04T12:00:00Z'),
+    updatedAt: new Date('2025-07-04T12:00:00Z'),
+    text: 'Pergunta de exemplo',
+    questionType: QuestionType.MULTIPLA_ESCOLHA,
+    difficulty: Difficulty.FACIL,
+    topicId: 'topic-uuid',
+    subtopicId: null,
+    explanation: null,
+    bancaId: 'banca-uuid',
+    sourceConcurso: 'Concurso Exemplo',
+    sourceCargo: 'Cargo Exemplo',
+    sourceYear: 2025,
+    questionStatus: 'ATIVA',
+    questionSubject: 'Assunto Exemplo',
+    sourceUrl: null,
+    authorId: null,
   };
 
-  const mockAuthenticatedAdminRequest: AuthenticatedRequest = {
-    user: {
-      sub: mockAdminId,
-      role: 'ADMIN',
-    },
-  } as AuthenticatedRequest;
-
-  const mockAuthenticatedStudentRequest: AuthenticatedRequest = {
-    user: {
-      sub: mockUserId,
-      role: 'STUDENT',
-    },
-  } as AuthenticatedRequest;
-
   beforeEach(async () => {
+    favoriteQuestionsService = mockDeep<FavoriteQuestionsService>();
+
     const module: TestingModule = await Test.createTestingModule({
       controllers: [FavoriteQuestionsController],
       providers: [
-        FavoriteQuestionsService,
-        { provide: PrismaService, useValue: mockPrismaService },
+        {
+          provide: FavoriteQuestionsService,
+          useValue: favoriteQuestionsService,
+        },
       ],
     }).compile();
 
-    controller = module.get<FavoriteQuestionsController>(FavoriteQuestionsController);
-    service = module.get<FavoriteQuestionsService>(FavoriteQuestionsService);
+    controller = module.get<FavoriteQuestionsController>(
+      FavoriteQuestionsController,
+    );
+
+    jest.useFakeTimers().setSystemTime(new Date('2025-07-04T12:00:00Z'));
   });
 
   afterEach(() => {
     jest.clearAllMocks();
+    jest.useRealTimers();
   });
 
   it('should be defined', () => {
@@ -74,150 +76,240 @@ describe('FavoriteQuestionsController', () => {
   });
 
   describe('findAll', () => {
-    it('should return a list of favorite questions for any authenticated user', async () => {
-      mockPrismaService.favoriteQuestion.findMany.mockResolvedValue([mockFavoriteQuestion]);
+    it('should return list of favorite questions for any authenticated user', async () => {
+      favoriteQuestionsService.findManyByUserId.mockResolvedValue([
+        mockFavoriteQuestion,
+      ]);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest);
+      const result = await controller.findAll(studentReq);
 
       expect(result).toEqual([mockFavoriteQuestion]);
-      expect(mockPrismaService.favoriteQuestion.findMany).toHaveBeenCalledTimes(1);
+      expect(favoriteQuestionsService.findManyByUserId).toHaveBeenCalledWith(
+        studentReq.user.sub,
+      );
     });
+  });
 
-    it('should return favorite question by ID for any authenticated user', async () => {
-      mockPrismaService.favoriteQuestion.findUnique.mockResolvedValue(mockFavoriteQuestion);
+  describe('findOne', () => {
+    it('should return favorite question by userId and questionId', async () => {
+      favoriteQuestionsService.findOne.mockResolvedValue(mockFavoriteQuestion);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockFavoriteQuestionId);
+      const result = await controller.findOne(
+        studentReq,
+        studentReq.user.sub,
+        mockQuestionId,
+      );
 
       expect(result).toEqual(mockFavoriteQuestion);
-      expect(mockPrismaService.favoriteQuestion.findUnique).toHaveBeenCalledWith({ where: { id: mockFavoriteQuestionId } });
+      expect(favoriteQuestionsService.findOne).toHaveBeenCalledWith({
+        userId_questionId: {
+          userId: studentReq.user.sub,
+          questionId: mockQuestionId,
+        },
+      });
     });
 
-    it('should throw BadRequestException for invalid favorite question ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException if userId or questionId are invalid UUIDs', async () => {
+      await expect(
+        controller.findOne(studentReq, 'invalid-uuid', 'invalid-uuid'),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it('should throw NotFoundException when favorite question not found', async () => {
-      mockPrismaService.favoriteQuestion.findUnique.mockResolvedValue(null);
+    it('should throw NotFoundException if favorite question not found', async () => {
+      favoriteQuestionsService.findOne.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
-    });
-
-    it('should apply filters when provided', async () => {
-      mockPrismaService.favoriteQuestion.findMany.mockResolvedValue([]);
-
-      const filters = {
-        userId: randomUUID(),
-        questionId: randomUUID(),
-        limit: '10',
-        offset: '0',
-      };
-
-      await controller.findAll(
-        mockAuthenticatedStudentRequest,
-        undefined,
-        filters.userId,
-        filters.questionId,
-        filters.limit,
-        filters.offset,
-      );
-
-      expect(mockPrismaService.favoriteQuestion.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: filters.userId,
-          questionId: filters.questionId,
-        },
-        take: 10,
-        skip: 0,
-      }));
+      await expect(
+        controller.findOne(studentReq, studentReq.user.sub, mockQuestionId),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
   describe('create', () => {
     const createFavoriteQuestionDto = {
-      userId: mockUserId,
+      userId: studentReq.user.sub,
       questionId: mockQuestionId,
+      markedAt: new Date('2025-07-04T12:00:00Z'),
     };
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { userId: 'invalid', questionId: 'invalid' };
-      await expect(controller.create(invalidDto)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid UUIDs', async () => {
+      const invalidDto = {
+        userId: 'invalid',
+        questionId: 'invalid',
+        markedAt: new Date('2025-07-04T12:00:00Z'),
+      };
+
+      await expect(controller.create(invalidDto, adminReq)).rejects.toThrow(
+        BadRequestException,
+      );
     });
 
-    it("should create favorite question for STUDENT for themselves", async () => {
-      const createdFavoriteQuestion = { id: randomUUID(), ...createFavoriteQuestionDto, createdAt: new Date() };
-      mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
-      mockPrismaService.question.findUnique.mockResolvedValue({ id: mockQuestionId });
-      mockPrismaService.favoriteQuestion.create.mockResolvedValue(createdFavoriteQuestion);
+    it('should create favorite question for STUDENT for themselves', async () => {
+      favoriteQuestionsService.findUser.mockResolvedValue({
+        id: studentReq.user.sub,
+        name: 'Test User',
+        email: 'testuser@example.com',
+        emailVerified: null,
+        image: null,
+        role: UserRole.STUDENT,
+        bio: null,
+        socialLinks: {},
+        createdAt: new Date(),
+        updatedAt: new Date(),
+      });
+      favoriteQuestionsService.findQuestionById.mockResolvedValue(mockQuestion);
+      favoriteQuestionsService.create.mockResolvedValue(
+        createFavoriteQuestionDto,
+      );
 
-      const result = await controller.create(createFavoriteQuestionDto);
+      const result = await controller.create(
+        createFavoriteQuestionDto,
+        studentReq,
+      );
 
-      expect(result).toEqual(createdFavoriteQuestion);
-      expect(mockPrismaService.favoriteQuestion.create).toHaveBeenCalledWith({ data: createFavoriteQuestionDto });
+      expect(result).toEqual(createFavoriteQuestionDto);
+      expect(favoriteQuestionsService.create).toHaveBeenCalledWith({
+        user: { connect: { id: createFavoriteQuestionDto.userId } },
+        question: { connect: { id: createFavoriteQuestionDto.questionId } },
+        markedAt: expect.any(Date) as Date,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { userId: 'invalid', questionId: 'invalid' };
-      await expect(controller.create(invalidDto)).rejects.toThrow(BadRequestException);
+    it('should throw ForbiddenException if STUDENT tries to create favorite question for another user', async () => {
+      const otherStudentRequest = {
+        user: { sub: randomUUID(), role: UserRole.STUDENT },
+      } as typeof studentReq;
+
+      favoriteQuestionsService.findUser.mockResolvedValue({
+        id: otherStudentRequest.user.sub,
+        email: 'otherstudent@example.com',
+        name: 'Other Student',
+        emailVerified: null,
+        image: null,
+        role: UserRole.STUDENT,
+        bio: null,
+        socialLinks: {},
+        createdAt: new Date(),
+        updatedAt: new Date(),
+      });
+      favoriteQuestionsService.findQuestionById.mockResolvedValue(mockQuestion);
+
+      await expect(
+        controller.create(createFavoriteQuestionDto, otherStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw ForbiddenException for STUDENT creating favorite question for another user", async () => {
-      const otherUserId = randomUUID();
-      const otherStudentRequest = { user: { sub: otherUserId, role: 'STUDENT' } } as AuthenticatedRequest;
+    it('should throw NotFoundException if user not found', async () => {
+      favoriteQuestionsService.findUser.mockResolvedValue(null);
+      favoriteQuestionsService.findQuestionById.mockResolvedValue(mockQuestion);
 
-      await expect(controller.create(createFavoriteQuestionDto)).rejects.toThrow(ForbiddenException);
-    });
+      const fakeUserId = randomUUID();
 
-    it("should throw NotFoundException if user not found", async () => {
-      mockPrismaService.user.findUnique.mockResolvedValue(null);
-      mockPrismaService.question.findUnique.mockResolvedValue({ id: mockQuestionId });
+      const dtoWithNonExistentUser = {
+        userId: fakeUserId,
+        questionId: mockQuestionId,
+        markedAt: new Date(),
+      };
 
-      await expect(controller.create(createFavoriteQuestionDto)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.create(dtoWithNonExistentUser, {
+          user: { sub: fakeUserId, role: UserRole.STUDENT },
+        } as typeof studentReq),
+      ).rejects.toThrow(NotFoundException);
     });
 
-    it("should throw NotFoundException if question not found", async () => {
-      mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
-      mockPrismaService.question.findUnique.mockResolvedValue(null);
-
-      await expect(controller.create(createFavoriteQuestionDto)).rejects.toThrow(NotFoundException);
+    it('should throw NotFoundException if question not found', async () => {
+      favoriteQuestionsService.findUser.mockResolvedValue({
+        id: studentReq.user.sub,
+        email: 'otherstudent@example.com',
+        name: 'Other Student',
+        emailVerified: null,
+        image: null,
+        role: UserRole.STUDENT,
+        bio: null,
+        socialLinks: {},
+        createdAt: new Date(),
+        updatedAt: new Date(),
+      });
+      favoriteQuestionsService.findQuestionById.mockResolvedValue(null);
+
+      await expect(
+        controller.create(createFavoriteQuestionDto, studentReq),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
   describe('remove', () => {
     it('should delete favorite question for ADMIN', async () => {
-      mockPrismaService.favoriteQuestion.findUnique.mockResolvedValue(mockFavoriteQuestion);
-      mockPrismaService.favoriteQuestion.delete.mockResolvedValue(mockFavoriteQuestion);
-
-      const result = await controller.remove(mockFavoriteQuestionId, mockAuthenticatedAdminRequest);
+      favoriteQuestionsService.findOne.mockResolvedValue(mockFavoriteQuestion);
+      favoriteQuestionsService.remove.mockResolvedValue({
+        markedAt: new Date(),
+        questionId: mockQuestionId,
+        userId: adminReq.user.sub,
+      });
+
+      const result = await controller.remove(
+        adminReq.user.sub,
+        mockQuestionId,
+        adminReq,
+      );
 
       expect(result).toEqual({ message: 'Favorite question deleted' });
-      expect(mockPrismaService.favoriteQuestion.delete).toHaveBeenCalledWith({ where: { id: mockFavoriteQuestionId } });
+      expect(favoriteQuestionsService.remove).toHaveBeenCalledWith({
+        userId_questionId: {
+          userId: adminReq.user.sub,
+          questionId: mockQuestionId,
+        },
+      });
     });
 
     it('should delete own favorite question for STUDENT', async () => {
-      mockPrismaService.favoriteQuestion.findUnique.mockResolvedValue(mockFavoriteQuestion);
-      mockPrismaService.favoriteQuestion.delete.mockResolvedValue(mockFavoriteQuestion);
-
-      const result = await controller.remove(mockFavoriteQuestionId, mockAuthenticatedStudentRequest);
+      favoriteQuestionsService.findOne.mockResolvedValue(mockFavoriteQuestion);
+      favoriteQuestionsService.remove.mockResolvedValue({
+        markedAt: new Date(),
+        questionId: mockQuestionId,
+        userId: adminReq.user.sub,
+      });
+
+      const result = await controller.remove(
+        studentReq.user.sub,
+        mockQuestionId,
+        studentReq,
+      );
 
       expect(result).toEqual({ message: 'Favorite question deleted' });
-      expect(mockPrismaService.favoriteQuestion.delete).toHaveBeenCalledWith({ where: { id: mockFavoriteQuestionId } });
+      expect(favoriteQuestionsService.remove).toHaveBeenCalledWith({
+        userId_questionId: {
+          userId: studentReq.user.sub,
+          questionId: mockQuestionId,
+        },
+      });
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove('invalid-id', mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid IDs', async () => {
+      await expect(
+        controller.remove('invalid-id', mockQuestionId, adminReq),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for STUDENT deleting other user favorite question", async () => {
-      mockPrismaService.favoriteQuestion.findUnique.mockResolvedValue({ ...mockFavoriteQuestion, userId: randomUUID() });
+    it('should throw ForbiddenException if STUDENT deletes other user favorite question', async () => {
+      const fakeUserId = randomUUID();
 
-      await expect(controller.remove(mockFavoriteQuestionId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      favoriteQuestionsService.findOne.mockResolvedValue({
+        ...mockFavoriteQuestion,
+        userId: fakeUserId,
+      });
+
+      await expect(
+        controller.remove(fakeUserId, mockQuestionId, studentReq),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it('should throw NotFoundException when favorite question not found', async () => {
-      mockPrismaService.favoriteQuestion.findUnique.mockResolvedValue(null);
+    it('should throw NotFoundException if favorite question not found', async () => {
+      favoriteQuestionsService.findOne.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(studentReq.user.sub, mockQuestionId, studentReq),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 });
-
diff --git a/src/favorite-questions/favorite-questions.controller.ts b/src/favorite-questions/favorite-questions.controller.ts
index f5c2a8f..b967a66 100644
--- a/src/favorite-questions/favorite-questions.controller.ts
+++ b/src/favorite-questions/favorite-questions.controller.ts
@@ -9,13 +9,23 @@ import {
   UseGuards,
   Request,
   Query,
+  ForbiddenException,
+  NotFoundException,
+  BadRequestException,
 } from '@nestjs/common';
 import { FavoriteQuestionsService } from './favorite-questions.service';
-import { Prisma } from '@prisma/client';
 import { JwtAuthGuard } from '../auth/jwt-auth.guard/jwt-auth.guard';
 import { RolesGuard } from '../auth/roles.guard/roles.guard';
 import { Roles } from '../auth/roles.decorator/roles.decorator';
 import { UserRole } from '@prisma/client';
+import { AuthenticatedRequest } from 'src/common/interfaces/authenticated-request.interface';
+import {
+  FavoriteQuestionDto,
+  UpdateFavoriteQuestionDto,
+} from './favorite-questions.dto';
+import { ParseUUIDPipe } from '@nestjs/common';
+import { isUUID } from 'class-validator';
+import { FindQuestionsFiltersDto } from '../common/dto/filters.dto';
 
 @Controller('favorite-questions')
 export class FavoriteQuestionsController {
@@ -26,60 +36,138 @@ export class FavoriteQuestionsController {
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN, UserRole.STUDENT)
   @Post()
-  create(
-    @Body() createFavoriteQuestionDto: Prisma.FavoriteQuestionCreateInput,
+  async create(
+    @Body() createFavoriteQuestionDto: FavoriteQuestionDto,
+    @Request() req: AuthenticatedRequest,
   ) {
-    return this.favoriteQuestionsService.create(createFavoriteQuestionDto);
+    if (
+      !isUUID(createFavoriteQuestionDto.userId) ||
+      !isUUID(createFavoriteQuestionDto.questionId)
+    ) {
+      throw new BadRequestException('Invalid userId or questionId format');
+    }
+    const user = await this.favoriteQuestionsService.findUser(
+      createFavoriteQuestionDto.userId,
+    );
+    const question = await this.favoriteQuestionsService.findQuestionById(
+      createFavoriteQuestionDto.questionId,
+    );
+
+    if (!user) {
+      throw new NotFoundException('User not found');
+    }
+    if (!question) {
+      throw new NotFoundException('Question not found');
+    }
+
+    if (
+      req.user.role === UserRole.ADMIN ||
+      req.user.sub === createFavoriteQuestionDto.userId
+    ) {
+      return this.favoriteQuestionsService.create({
+        user: { connect: { id: createFavoriteQuestionDto.userId } },
+        question: { connect: { id: createFavoriteQuestionDto.questionId } },
+        markedAt: new Date(),
+      });
+    }
+
+    throw new ForbiddenException(
+      'You can only create favorite questions for yourself.',
+    );
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN, UserRole.STUDENT)
   @Get()
-  findAll(@Request() req: any) {
+  async findAll(
+    @Request() req: AuthenticatedRequest,
+    @Query() filters?: FindQuestionsFiltersDto, // Aqui você vai pegar os filtros da query string
+  ) {
+    // Se o filtro for passado, aplica o filtro
+    if (filters) {
+      return this.favoriteQuestionsService.findAll(filters);
+    }
+
+    // Caso o usuário seja ADMIN, retorna todos os favoritos
     if (req.user.role === UserRole.ADMIN) {
       return this.favoriteQuestionsService.findAll();
-    } else if (req.user.role === UserRole.STUDENT) {
-      return this.favoriteQuestionsService.findManyByUserId(req.user.userId);
-    } else {
-      return [];
     }
+
+    // Caso o usuário seja STUDENT, retorna os favoritos do próprio usuário
+    return this.favoriteQuestionsService.findManyByUserId(req.user.sub);
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN, UserRole.STUDENT)
   @Get(':userId/:questionId')
-  findOne(
-    @Param('userId') userId: string,
-    @Param('questionId') questionId: string,
+  async findOne(
+    @Request() req: AuthenticatedRequest,
+    @Param('userId', ParseUUIDPipe) userId: string,
+    @Param('questionId', ParseUUIDPipe) questionId: string,
   ) {
-    return this.favoriteQuestionsService.findOne({
+    if (!isUUID(userId) || !isUUID(questionId)) {
+      throw new BadRequestException('Invalid userId or questionId format');
+    }
+    const favoriteQuestion = await this.favoriteQuestionsService.findOne({
       userId_questionId: { userId, questionId },
     });
+
+    if (!favoriteQuestion) {
+      throw new NotFoundException('Favorite question not found');
+    }
+
+    return favoriteQuestion;
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN, UserRole.STUDENT)
   @Patch(':userId/:questionId')
-  update(
-    @Param('userId') userId: string,
-    @Param('questionId') questionId: string,
-    @Body() updateFavoriteQuestionDto: Prisma.FavoriteQuestionUpdateInput,
+  async update(
+    @Param('userId', ParseUUIDPipe) userId: string,
+    @Param('questionId', ParseUUIDPipe) questionId: string,
+    @Request() req: AuthenticatedRequest,
+    @Body() updateFavoriteQuestionDto: UpdateFavoriteQuestionDto,
   ) {
-    return this.favoriteQuestionsService.update(
-      { userId_questionId: { userId, questionId } },
-      updateFavoriteQuestionDto,
+    if (req.user.role === UserRole.ADMIN || userId === req.user.sub) {
+      return this.favoriteQuestionsService.update(
+        { userId_questionId: { userId, questionId } },
+        updateFavoriteQuestionDto,
+      );
+    }
+
+    throw new ForbiddenException(
+      'You can only update your own favorite questions.',
     );
   }
 
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles(UserRole.ADMIN, UserRole.STUDENT)
   @Delete(':userId/:questionId')
-  remove(
-    @Param('userId') userId: string,
-    @Param('questionId') questionId: string,
+  async remove(
+    @Param('userId', ParseUUIDPipe) userId: string,
+    @Param('questionId', ParseUUIDPipe) questionId: string,
+    @Request() req: AuthenticatedRequest,
   ) {
-    return this.favoriteQuestionsService.remove({
+    if (!isUUID(userId) || !isUUID(questionId)) {
+      throw new BadRequestException('Invalid userId or questionId format');
+    }
+    const favoriteQuestion = await this.favoriteQuestionsService.findOne({
       userId_questionId: { userId, questionId },
     });
+
+    if (!favoriteQuestion) {
+      throw new NotFoundException('Favorite question not found');
+    }
+
+    if (req.user.role === UserRole.ADMIN || userId === req.user.sub) {
+      await this.favoriteQuestionsService.remove({
+        userId_questionId: { userId, questionId },
+      });
+      return { message: 'Favorite question deleted' };
+    }
+
+    throw new ForbiddenException(
+      'You can only delete your own favorite questions.',
+    );
   }
 }
diff --git a/src/favorite-questions/favorite-questions.dto.ts b/src/favorite-questions/favorite-questions.dto.ts
new file mode 100644
index 0000000..8fc417d
--- /dev/null
+++ b/src/favorite-questions/favorite-questions.dto.ts
@@ -0,0 +1,17 @@
+import { PartialType } from '@nestjs/mapped-types';
+import { IsUUID, IsDate } from 'class-validator';
+
+export class FavoriteQuestionDto {
+  @IsUUID()
+  userId!: string;
+
+  @IsUUID()
+  questionId!: string;
+
+  @IsDate()
+  markedAt!: Date;
+}
+
+export class UpdateFavoriteQuestionDto extends PartialType(
+  FavoriteQuestionDto,
+) {}
diff --git a/src/favorite-questions/favorite-questions.service.spec.ts b/src/favorite-questions/favorite-questions.service.spec.ts
index 5b0ddb8..69b3383 100644
--- a/src/favorite-questions/favorite-questions.service.spec.ts
+++ b/src/favorite-questions/favorite-questions.service.spec.ts
@@ -1,21 +1,264 @@
+/* eslint-disable @typescript-eslint/unbound-method */
 import { Test, TestingModule } from '@nestjs/testing';
 import { FavoriteQuestionsService } from './favorite-questions.service';
 import { PrismaService } from '../prisma/prisma.service';
+import { mockDeep, DeepMockProxy } from 'jest-mock-extended';
+import {
+  FavoriteQuestion,
+  Question,
+  User,
+  Prisma,
+
+} from '@prisma/client';
 
 describe('FavoriteQuestionsService', () => {
   let service: FavoriteQuestionsService;
-  let prismaService: PrismaService;
+  let prismaService: DeepMockProxy<PrismaService>;
 
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
-      providers: [FavoriteQuestionsService, PrismaService],
+      providers: [
+        FavoriteQuestionsService,
+        {
+          provide: PrismaService,
+          useValue: mockDeep<PrismaService>(),
+        },
+      ],
     }).compile();
 
-    service = module.get<FavoriteQuestionsService>(FavoriteQuestionsService);
-    prismaService = module.get<PrismaService>(PrismaService);
+    service = module.get(FavoriteQuestionsService);
+    prismaService = module.get(PrismaService);
+  });
+
+  afterEach(() => {
+    jest.clearAllMocks();
   });
 
   it('should be defined', () => {
     expect(service).toBeDefined();
   });
+
+  describe('create', () => {
+    it('should create a favorite question', async () => {
+      const data: Prisma.FavoriteQuestionCreateInput = {
+        markedAt: new Date(),
+        question: { connect: { id: 'q1' } },
+        user: { connect: { id: 'u1' } },
+      };
+
+      const mockFavoriteQuestion: FavoriteQuestion = {
+        userId: 'u1',
+        questionId: 'q1',
+        markedAt: data.markedAt as Date,
+      };
+
+      prismaService.favoriteQuestion.create.mockResolvedValue(
+        mockFavoriteQuestion,
+      );
+
+      const result = await service.create(data);
+
+      expect(prismaService.favoriteQuestion.create).toHaveBeenCalledWith({
+        data,
+      });
+      expect(result).toEqual(mockFavoriteQuestion);
+    });
+  });
+
+  describe('findAll', () => {
+    it('should return filtered favorite questions', async () => {
+      const filters = {
+        userId: 'u1',
+        questionId: 'q1',
+        limit: 10,
+        offset: 0,
+      };
+
+      const mockResponse: FavoriteQuestion[] = [
+        {
+          userId: 'u1',
+          questionId: 'q1',
+          markedAt: new Date(),
+        },
+      ];
+
+      prismaService.favoriteQuestion.findMany.mockResolvedValue(mockResponse);
+
+      const result = await service.findAll(filters);
+
+      expect(prismaService.favoriteQuestion.findMany).toHaveBeenCalledWith({
+        where: {
+          userId: 'u1',
+          questionId: 'q1',
+        },
+        take: 10,
+        skip: 0,
+        orderBy: { markedAt: 'desc' },
+        include: { question: true, user: true },
+      });
+
+      expect(result).toEqual(mockResponse);
+    });
+  });
+
+  describe('findOne', () => {
+    it('should return a favorite question by unique input', async () => {
+      const uniqueInput: Prisma.FavoriteQuestionWhereUniqueInput = {
+        userId_questionId: { userId: 'u1', questionId: 'q1' },
+      };
+
+      const mockResponse: FavoriteQuestion = {
+        userId: 'u1',
+        questionId: 'q1',
+        markedAt: new Date(),
+      };
+
+      prismaService.favoriteQuestion.findUnique.mockResolvedValue(mockResponse);
+
+      const result = await service.findOne(uniqueInput);
+
+      expect(prismaService.favoriteQuestion.findUnique).toHaveBeenCalledWith({
+        where: uniqueInput,
+      });
+
+      expect(result).toEqual(mockResponse);
+    });
+  });
+
+  describe('update', () => {
+    it('should update a favorite question', async () => {
+      const uniqueInput: Prisma.FavoriteQuestionWhereUniqueInput = {
+        userId_questionId: { userId: 'u1', questionId: 'q1' },
+      };
+      const data: Prisma.FavoriteQuestionUpdateInput = {
+        markedAt: new Date(),
+      };
+
+      const mockResponse: FavoriteQuestion = {
+        userId: 'u1',
+        questionId: 'q1',
+        markedAt: data.markedAt as Date,
+      };
+
+      prismaService.favoriteQuestion.update.mockResolvedValue(mockResponse);
+
+      const result = await service.update(uniqueInput, data);
+
+      expect(prismaService.favoriteQuestion.update).toHaveBeenCalledWith({
+        where: uniqueInput,
+        data,
+      });
+
+      expect(result).toEqual(mockResponse);
+    });
+  });
+
+  describe('remove', () => {
+    it('should delete a favorite question', async () => {
+      const uniqueInput: Prisma.FavoriteQuestionWhereUniqueInput = {
+        userId_questionId: { userId: 'u1', questionId: 'q1' },
+      };
+
+      const mockResponse: FavoriteQuestion = {
+        userId: 'u1',
+        questionId: 'q1',
+        markedAt: new Date(),
+      };
+
+      prismaService.favoriteQuestion.delete.mockResolvedValue(mockResponse);
+
+      const result = await service.remove(uniqueInput);
+
+      expect(prismaService.favoriteQuestion.delete).toHaveBeenCalledWith({
+        where: uniqueInput,
+      });
+
+      expect(result).toEqual(mockResponse);
+    });
+  });
+
+  describe('findManyByUserId', () => {
+    it('should return all favorite questions by userId', async () => {
+      const userId = 'u1';
+
+      const mockResponse: FavoriteQuestion[] = [
+        {
+          userId,
+          questionId: 'q1',
+          markedAt: new Date(),
+        },
+      ];
+
+      prismaService.favoriteQuestion.findMany.mockResolvedValue(mockResponse);
+
+      const result = await service.findManyByUserId(userId);
+
+      expect(prismaService.favoriteQuestion.findMany).toHaveBeenCalledWith({
+        where: { userId },
+      });
+
+      expect(result).toEqual(mockResponse);
+    });
+  });
+
+  describe('findQuestionById', () => {
+    it('should return a question by ID', async () => {
+      const questionId = 'q1';
+      const mockQuestion: Question = {
+        id: questionId,
+        text: 'Sample content',
+        explanation: 'Sample explanation',
+        sourceCargo: 'Cargo XYZ',
+        sourceUrl: 'https://example.com',
+        sourceYear: 2021,
+        questionType: 'MULTIPLA_ESCOLHA',
+        difficulty: 'DIFICIL',
+        topicId: 'topic1',
+        subtopicId: 'subtopic1',
+        bancaId: 'banca1',
+        sourceConcurso: 'Concurso XYZ',
+        authorId: 'u1',
+        createdAt: new Date(),
+        updatedAt: new Date(),
+      };
+
+      prismaService.question.findUnique.mockResolvedValue(mockQuestion);
+
+      const result = await service.findQuestionById(questionId);
+
+      expect(prismaService.question.findUnique).toHaveBeenCalledWith({
+        where: { id: questionId },
+      });
+
+      expect(result).toEqual(mockQuestion);
+    });
+  });
+
+  describe('findUser', () => {
+    it('should return a user by ID', async () => {
+      const userId = 'u1';
+      const mockUser: User = {
+        id: userId,
+        name: 'John Doe',
+        email: 'john@example.com',
+        emailVerified: null,
+        image: 'https://example.com/avatar.jpg',
+        role: 'STUDENT', // ou ADMIN, MODERATOR etc., conforme enum definido
+        bio: 'Software developer and educator',
+        socialLinks: null, // ou um JSON/objeto/string, dependendo do seu schema
+        createdAt: new Date(),
+        updatedAt: new Date(),
+      };
+
+      prismaService.user.findUnique.mockResolvedValue(mockUser);
+
+      const result = await service.findUser(userId);
+
+      expect(prismaService.user.findUnique).toHaveBeenCalledWith({
+        where: { id: userId },
+      });
+
+      expect(result).toEqual(mockUser);
+    });
+  });
 });
diff --git a/src/favorite-questions/favorite-questions.service.ts b/src/favorite-questions/favorite-questions.service.ts
index 0a38c9f..cebafaf 100644
--- a/src/favorite-questions/favorite-questions.service.ts
+++ b/src/favorite-questions/favorite-questions.service.ts
@@ -1,6 +1,7 @@
 import { Injectable } from '@nestjs/common';
 import { PrismaService } from '../prisma/prisma.service';
 import { Prisma } from '@prisma/client';
+import { FindQuestionsFiltersDto } from '../common/dto/filters.dto';
 
 @Injectable()
 export class FavoriteQuestionsService {
@@ -10,7 +11,24 @@ export class FavoriteQuestionsService {
     return this.prisma.favoriteQuestion.create({ data });
   }
 
-  async findAll() {
+  async findAll(filters?: FindQuestionsFiltersDto) {
+    if (filters) {
+      const { userId, questionId, limit, offset } = filters;
+      const where: Prisma.FavoriteQuestionWhereInput = {};
+      if (userId) {
+        where.userId = userId;
+      }
+      if (questionId) {
+        where.questionId = questionId;
+      }
+      return this.prisma.favoriteQuestion.findMany({
+        where,
+        take: limit,
+        skip: offset,
+        orderBy: { markedAt: 'desc' },
+        include: { question: true, user: true },
+      });
+    }
     return this.prisma.favoriteQuestion.findMany();
   }
 
@@ -39,4 +57,14 @@ export class FavoriteQuestionsService {
   async remove(userId_questionId: Prisma.FavoriteQuestionWhereUniqueInput) {
     return this.prisma.favoriteQuestion.delete({ where: userId_questionId });
   }
+
+  async findQuestionById(questionId: string) {
+    return this.prisma.question.findUnique({ where: { id: questionId } });
+  }
+
+  async findUser(userId: string) {
+    return this.prisma.user.findUnique({
+      where: { id: userId },
+    });
+  }
 }
diff --git a/src/lessons/lessons.controller.spec.ts b/src/lessons/lessons.controller.spec.ts
index 2ca26bf..ad174eb 100644
--- a/src/lessons/lessons.controller.spec.ts
+++ b/src/lessons/lessons.controller.spec.ts
@@ -4,7 +4,11 @@ import { LessonsService } from './lessons.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('LessonsController', () => {
   let controller: LessonsController;
@@ -95,17 +99,23 @@ describe('LessonsController', () => {
       const result = await controller.findOne(mockLessonId);
 
       expect(result).toEqual(mockLesson);
-      expect(mockPrismaService.lesson.findUnique).toHaveBeenCalledWith({ where: { id: mockLessonId } });
+      expect(mockPrismaService.lesson.findUnique).toHaveBeenCalledWith({
+        where: { id: mockLessonId },
+      });
     });
 
     it('should throw BadRequestException for invalid lesson ID', async () => {
-      await expect(controller.findOne("invalid-id")).rejects.toThrow(BadRequestException);
+      await expect(controller.findOne('invalid-id')).rejects.toThrow(
+        BadRequestException,
+      );
     });
 
     it('should throw NotFoundException when lesson not found', async () => {
       mockPrismaService.lesson.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findOne(randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(controller.findOne(randomUUID())).rejects.toThrow(
+        NotFoundException,
+      );
     });
 
     it('should apply filters when provided', async () => {
@@ -119,13 +129,15 @@ describe('LessonsController', () => {
 
       await controller.findAll();
 
-      expect(mockPrismaService.lesson.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          moduleId: filters.moduleId,
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.lesson.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            moduleId: filters.moduleId,
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -139,39 +151,53 @@ describe('LessonsController', () => {
 
     it('should create lesson for ADMIN', async () => {
       const createdLesson = { id: randomUUID(), ...createLessonDto };
-      mockPrismaService.module.findUnique.mockResolvedValue({ id: mockModuleId });
+      mockPrismaService.module.findUnique.mockResolvedValue({
+        id: mockModuleId,
+      });
       mockPrismaService.lesson.create.mockResolvedValue(createdLesson);
 
       const result = await controller.create(createLessonDto);
 
       expect(result).toEqual(createdLesson);
-      expect(mockPrismaService.lesson.create).toHaveBeenCalledWith({ data: createLessonDto });
+      expect(mockPrismaService.lesson.create).toHaveBeenCalledWith({
+        data: createLessonDto,
+      });
     });
 
     it('should create lesson for PROFESSOR', async () => {
       const createdLesson = { id: randomUUID(), ...createLessonDto };
-      mockPrismaService.module.findUnique.mockResolvedValue({ id: mockModuleId });
+      mockPrismaService.module.findUnique.mockResolvedValue({
+        id: mockModuleId,
+      });
       mockPrismaService.lesson.create.mockResolvedValue(createdLesson);
 
       const result = await controller.create(createLessonDto);
 
       expect(result).toEqual(createdLesson);
-      expect(mockPrismaService.lesson.create).toHaveBeenCalledWith({ data: createLessonDto });
+      expect(mockPrismaService.lesson.create).toHaveBeenCalledWith({
+        data: createLessonDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { ...createLessonDto, title: '' };
-      await expect(controller.create(invalidDto)).rejects.toThrow(BadRequestException);
+      await expect(controller.create(invalidDto)).rejects.toThrow(
+        BadRequestException,
+      );
     });
 
-    it("should throw ForbiddenException for STUDENT", async () => {
-      await expect(controller.create(createLessonDto)).rejects.toThrow(ForbiddenException);
+    it('should throw ForbiddenException for STUDENT', async () => {
+      await expect(controller.create(createLessonDto)).rejects.toThrow(
+        ForbiddenException,
+      );
     });
 
     it('should throw NotFoundException if module not found', async () => {
       mockPrismaService.module.findUnique.mockResolvedValue(null);
 
-      await expect(controller.create(createLessonDto)).rejects.toThrow(NotFoundException);
+      await expect(controller.create(createLessonDto)).rejects.toThrow(
+        NotFoundException,
+      );
     });
   });
 
@@ -186,7 +212,10 @@ describe('LessonsController', () => {
       const result = await controller.update(mockLessonId, updateDto);
 
       expect(result).toEqual(updatedLesson);
-      expect(mockPrismaService.lesson.update).toHaveBeenCalledWith({ where: { id: mockLessonId }, data: updateDto });
+      expect(mockPrismaService.lesson.update).toHaveBeenCalledWith({
+        where: { id: mockLessonId },
+        data: updateDto,
+      });
     });
 
     it('should update lesson for PROFESSOR', async () => {
@@ -197,28 +226,43 @@ describe('LessonsController', () => {
       const result = await controller.update(mockLessonId, updateDto);
 
       expect(result).toEqual(updatedLesson);
-      expect(mockPrismaService.lesson.update).toHaveBeenCalledWith({ where: { id: mockLessonId }, data: updateDto });
+      expect(mockPrismaService.lesson.update).toHaveBeenCalledWith({
+        where: { id: mockLessonId },
+        data: updateDto,
+      });
     });
 
     it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.lesson.findUnique.mockResolvedValue(mockLesson);
 
-      await expect(controller.update(mockLessonId, updateDto)).rejects.toThrow(ForbiddenException);
+      await expect(controller.update(mockLessonId, updateDto)).rejects.toThrow(
+        ForbiddenException,
+      );
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.update("invalid-id", updateDto)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(controller.update('invalid-id', updateDto)).rejects.toThrow(
+        BadRequestException,
+      );
     });
 
     it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { title: '' };
-      await expect(controller.update(mockLessonId, invalidDto)).rejects.toThrow(BadRequestException);
+      await expect(controller.update(mockLessonId, invalidDto)).rejects.toThrow(
+        BadRequestException,
+      );
     });
 
     it('should throw NotFoundException when lesson not found', async () => {
       mockPrismaService.lesson.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -230,7 +274,9 @@ describe('LessonsController', () => {
       const result = await controller.remove(mockLessonId);
 
       expect(result).toEqual({ message: 'Lesson deleted' });
-      expect(mockPrismaService.lesson.delete).toHaveBeenCalledWith({ where: { id: mockLessonId } });
+      expect(mockPrismaService.lesson.delete).toHaveBeenCalledWith({
+        where: { id: mockLessonId },
+      });
     });
 
     it('should delete lesson for PROFESSOR', async () => {
@@ -240,19 +286,25 @@ describe('LessonsController', () => {
       const result = await controller.remove(mockLessonId);
 
       expect(result).toEqual({ message: 'Lesson deleted' });
-      expect(mockPrismaService.lesson.delete).toHaveBeenCalledWith({ where: { id: mockLessonId } });
+      expect(mockPrismaService.lesson.delete).toHaveBeenCalledWith({
+        where: { id: mockLessonId },
+      });
     });
 
-    it("should throw ForbiddenException for STUDENT", async () => {
+    it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.lesson.findUnique.mockResolvedValue(mockLesson);
 
-      await expect(controller.remove(mockLessonId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockLessonId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw NotFoundException when lesson not found', async () => {
       mockPrismaService.lesson.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
-});
\ No newline at end of file
+});
diff --git a/src/modules/modules.controller.spec.ts b/src/modules/modules.controller.spec.ts
index 30a7553..5e1d3b5 100644
--- a/src/modules/modules.controller.spec.ts
+++ b/src/modules/modules.controller.spec.ts
@@ -4,7 +4,11 @@ import { ModulesService } from './modules.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('ModulesController', () => {
   let controller: ModulesController;
@@ -92,20 +96,29 @@ describe('ModulesController', () => {
     it('should return module by ID for any authenticated user', async () => {
       mockPrismaService.module.findUnique.mockResolvedValue(mockModule);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockModuleId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockModuleId,
+      );
 
       expect(result).toEqual(mockModule);
-      expect(mockPrismaService.module.findUnique).toHaveBeenCalledWith({ where: { id: mockModuleId } });
+      expect(mockPrismaService.module.findUnique).toHaveBeenCalledWith({
+        where: { id: mockModuleId },
+      });
     });
 
     it('should throw BadRequestException for invalid module ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when module not found', async () => {
       mockPrismaService.module.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -125,13 +138,15 @@ describe('ModulesController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.module.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          courseId: filters.courseId,
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.module.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            courseId: filters.courseId,
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -145,39 +160,59 @@ describe('ModulesController', () => {
 
     it('should create module for ADMIN', async () => {
       const createdModule = { id: randomUUID(), ...createModuleDto };
-      mockPrismaService.course.findUnique.mockResolvedValue({ id: mockCourseId });
+      mockPrismaService.course.findUnique.mockResolvedValue({
+        id: mockCourseId,
+      });
       mockPrismaService.module.create.mockResolvedValue(createdModule);
 
-      const result = await controller.create(createModuleDto, mockAuthenticatedAdminRequest);
+      const result = await controller.create(
+        createModuleDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(createdModule);
-      expect(mockPrismaService.module.create).toHaveBeenCalledWith({ data: createModuleDto });
+      expect(mockPrismaService.module.create).toHaveBeenCalledWith({
+        data: createModuleDto,
+      });
     });
 
     it('should create module for PROFESSOR', async () => {
       const createdModule = { id: randomUUID(), ...createModuleDto };
-      mockPrismaService.course.findUnique.mockResolvedValue({ id: mockCourseId });
+      mockPrismaService.course.findUnique.mockResolvedValue({
+        id: mockCourseId,
+      });
       mockPrismaService.module.create.mockResolvedValue(createdModule);
 
-      const result = await controller.create(createModuleDto, mockAuthenticatedProfessorRequest);
+      const result = await controller.create(
+        createModuleDto,
+        mockAuthenticatedProfessorRequest,
+      );
 
       expect(result).toEqual(createdModule);
-      expect(mockPrismaService.module.create).toHaveBeenCalledWith({ data: createModuleDto });
+      expect(mockPrismaService.module.create).toHaveBeenCalledWith({
+        data: createModuleDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { ...createModuleDto, title: '' };
-      await expect(controller.create(invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for STUDENT", async () => {
-      await expect(controller.create(createModuleDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+    it('should throw ForbiddenException for STUDENT', async () => {
+      await expect(
+        controller.create(createModuleDto, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw NotFoundException if course not found', async () => {
       mockPrismaService.course.findUnique.mockResolvedValue(null);
 
-      await expect(controller.create(createModuleDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.create(createModuleDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -189,10 +224,17 @@ describe('ModulesController', () => {
       mockPrismaService.module.findUnique.mockResolvedValue(mockModule);
       mockPrismaService.module.update.mockResolvedValue(updatedModule);
 
-      const result = await controller.update(mockModuleId, updateDto, mockAuthenticatedAdminRequest);
+      const result = await controller.update(
+        mockModuleId,
+        updateDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(updatedModule);
-      expect(mockPrismaService.module.update).toHaveBeenCalledWith({ where: { id: mockModuleId }, data: updateDto });
+      expect(mockPrismaService.module.update).toHaveBeenCalledWith({
+        where: { id: mockModuleId },
+        data: updateDto,
+      });
     });
 
     it('should update module for PROFESSOR', async () => {
@@ -200,31 +242,62 @@ describe('ModulesController', () => {
       mockPrismaService.module.findUnique.mockResolvedValue(mockModule);
       mockPrismaService.module.update.mockResolvedValue(updatedModule);
 
-      const result = await controller.update(mockModuleId, updateDto, mockAuthenticatedProfessorRequest);
+      const result = await controller.update(
+        mockModuleId,
+        updateDto,
+        mockAuthenticatedProfessorRequest,
+      );
 
       expect(result).toEqual(updatedModule);
-      expect(mockPrismaService.module.update).toHaveBeenCalledWith({ where: { id: mockModuleId }, data: updateDto });
+      expect(mockPrismaService.module.update).toHaveBeenCalledWith({
+        where: { id: mockModuleId },
+        data: updateDto,
+      });
     });
 
     it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.module.findUnique.mockResolvedValue(mockModule);
 
-      await expect(controller.update(mockModuleId, updateDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(
+          mockModuleId,
+          updateDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.update('invalid-id', updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { title: '' };
-      await expect(controller.update(mockModuleId, invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(
+          mockModuleId,
+          invalidDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when module not found', async () => {
       mockPrismaService.module.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -233,36 +306,52 @@ describe('ModulesController', () => {
       mockPrismaService.module.findUnique.mockResolvedValue(mockModule);
       mockPrismaService.module.delete.mockResolvedValue(mockModule);
 
-      const result = await controller.remove(mockModuleId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove(
+        mockModuleId,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual({ message: 'Module deleted' });
-      expect(mockPrismaService.module.delete).toHaveBeenCalledWith({ where: { id: mockModuleId } });
+      expect(mockPrismaService.module.delete).toHaveBeenCalledWith({
+        where: { id: mockModuleId },
+      });
     });
 
     it('should delete module for PROFESSOR', async () => {
       mockPrismaService.module.findUnique.mockResolvedValue(mockModule);
       mockPrismaService.module.delete.mockResolvedValue(mockModule);
 
-      const result = await controller.remove(mockModuleId, mockAuthenticatedProfessorRequest);
+      const result = await controller.remove(
+        mockModuleId,
+        mockAuthenticatedProfessorRequest,
+      );
 
       expect(result).toEqual({ message: 'Module deleted' });
-      expect(mockPrismaService.module.delete).toHaveBeenCalledWith({ where: { id: mockModuleId } });
+      expect(mockPrismaService.module.delete).toHaveBeenCalledWith({
+        where: { id: mockModuleId },
+      });
     });
 
     it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.module.findUnique.mockResolvedValue(mockModule);
 
-      await expect(controller.remove(mockModuleId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockModuleId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.remove('invalid-id', mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when module not found', async () => {
       mockPrismaService.module.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
-});
\ No newline at end of file
+});
diff --git a/src/notifications/notifications.controller.spec.ts b/src/notifications/notifications.controller.spec.ts
index 38db942..0480609 100644
--- a/src/notifications/notifications.controller.spec.ts
+++ b/src/notifications/notifications.controller.spec.ts
@@ -4,7 +4,11 @@ import { NotificationsService } from './notifications.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('NotificationsController', () => {
   let controller: NotificationsController;
@@ -70,7 +74,9 @@ describe('NotificationsController', () => {
 
   describe('findAll', () => {
     it('should return a list of notifications for ADMIN', async () => {
-      mockPrismaService.notification.findMany.mockResolvedValue([mockNotification]);
+      mockPrismaService.notification.findMany.mockResolvedValue([
+        mockNotification,
+      ]);
 
       const result = await controller.findAll(mockAuthenticatedAdminRequest);
 
@@ -79,50 +85,71 @@ describe('NotificationsController', () => {
     });
 
     it('should return notification by ID for ADMIN', async () => {
-      mockPrismaService.notification.findUnique.mockResolvedValue(mockNotification);
+      mockPrismaService.notification.findUnique.mockResolvedValue(
+        mockNotification,
+      );
 
       const result = await controller.findOne(mockNotificationId);
 
       expect(result).toEqual(mockNotification);
-      expect(mockPrismaService.notification.findUnique).toHaveBeenCalledWith({ where: { id: mockNotificationId } });
+      expect(mockPrismaService.notification.findUnique).toHaveBeenCalledWith({
+        where: { id: mockNotificationId },
+      });
     });
 
     it('should return own notifications for STUDENT', async () => {
-      mockPrismaService.notification.findMany.mockResolvedValue([mockNotification]);
+      mockPrismaService.notification.findMany.mockResolvedValue([
+        mockNotification,
+      ]);
 
       const result = await controller.findAll(mockAuthenticatedStudentRequest);
 
       expect(result).toEqual([mockNotification]);
-      expect(mockPrismaService.notification.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: mockUserId,
-        },
-      }));
+      expect(mockPrismaService.notification.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            userId: mockUserId,
+          },
+        }),
+      );
     });
 
     it('should return specific notification for STUDENT if it belongs to them', async () => {
-      mockPrismaService.notification.findUnique.mockResolvedValue(mockNotification);
+      mockPrismaService.notification.findUnique.mockResolvedValue(
+        mockNotification,
+      );
 
       const result = await controller.findOne(mockNotificationId);
 
       expect(result).toEqual(mockNotification);
-      expect(mockPrismaService.notification.findUnique).toHaveBeenCalledWith({ where: { id: mockNotificationId } });
+      expect(mockPrismaService.notification.findUnique).toHaveBeenCalledWith({
+        where: { id: mockNotificationId },
+      });
     });
 
     it('should throw ForbiddenException for STUDENT accessing other user notification', async () => {
-      mockPrismaService.notification.findUnique.mockResolvedValue({ ...mockNotification, userId: randomUUID() });
+      mockPrismaService.notification.findUnique.mockResolvedValue({
+        ...mockNotification,
+        userId: randomUUID(),
+      });
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedAdminRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedAdminRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when notification not found', async () => {
       mockPrismaService.notification.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedAdminRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedAdminRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -144,14 +171,16 @@ describe('NotificationsController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.notification.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: filters.userId,
-          read: filters.read,
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.notification.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            userId: filters.userId,
+            read: filters.read,
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -162,22 +191,35 @@ describe('NotificationsController', () => {
     };
 
     it('should create notification for ADMIN', async () => {
-      const createdNotification = { id: randomUUID(), ...createNotificationDto, read: false, createdAt: new Date() };
-      mockPrismaService.notification.create.mockResolvedValue(createdNotification);
+      const createdNotification = {
+        id: randomUUID(),
+        ...createNotificationDto,
+        read: false,
+        createdAt: new Date(),
+      };
+      mockPrismaService.notification.create.mockResolvedValue(
+        createdNotification,
+      );
 
       const result = await controller.create(createNotificationDto);
 
       expect(result).toEqual(createdNotification);
-      expect(mockPrismaService.notification.create).toHaveBeenCalledWith({ data: createNotificationDto });
+      expect(mockPrismaService.notification.create).toHaveBeenCalledWith({
+        data: createNotificationDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { ...createNotificationDto, userId: 'invalid-id' };
-      await expect(controller.create(invalidDto)).rejects.toThrow(BadRequestException);
+      await expect(controller.create(invalidDto)).rejects.toThrow(
+        BadRequestException,
+      );
     });
 
-    it("should throw ForbiddenException for STUDENT", async () => {
-      await expect(controller.create(createNotificationDto)).rejects.toThrow(ForbiddenException);
+    it('should throw ForbiddenException for STUDENT', async () => {
+      await expect(controller.create(createNotificationDto)).rejects.toThrow(
+        ForbiddenException,
+      );
     });
   });
 
@@ -186,83 +228,129 @@ describe('NotificationsController', () => {
 
     it('should update notification for ADMIN', async () => {
       const updatedNotification = { ...mockNotification, ...updateDto };
-      mockPrismaService.notification.findUnique.mockResolvedValue(mockNotification);
-      mockPrismaService.notification.update.mockResolvedValue(updatedNotification);
+      mockPrismaService.notification.findUnique.mockResolvedValue(
+        mockNotification,
+      );
+      mockPrismaService.notification.update.mockResolvedValue(
+        updatedNotification,
+      );
 
       const result = await controller.update(mockNotificationId, updateDto);
 
       expect(result).toEqual(updatedNotification);
-      expect(mockPrismaService.notification.update).toHaveBeenCalledWith({ where: { id: mockNotificationId }, data: updateDto });
+      expect(mockPrismaService.notification.update).toHaveBeenCalledWith({
+        where: { id: mockNotificationId },
+        data: updateDto,
+      });
     });
 
     it('should update own notification for STUDENT', async () => {
       const updatedNotification = { ...mockNotification, ...updateDto };
-      mockPrismaService.notification.findUnique.mockResolvedValue(mockNotification);
-      mockPrismaService.notification.update.mockResolvedValue(updatedNotification);
+      mockPrismaService.notification.findUnique.mockResolvedValue(
+        mockNotification,
+      );
+      mockPrismaService.notification.update.mockResolvedValue(
+        updatedNotification,
+      );
 
       const result = await controller.update(mockNotificationId, updateDto);
 
       expect(result).toEqual(updatedNotification);
-      expect(mockPrismaService.notification.update).toHaveBeenCalledWith({ where: { id: mockNotificationId }, data: updateDto });
+      expect(mockPrismaService.notification.update).toHaveBeenCalledWith({
+        where: { id: mockNotificationId },
+        data: updateDto,
+      });
     });
 
     it('should throw ForbiddenException for STUDENT updating other user notification', async () => {
-      mockPrismaService.notification.findUnique.mockResolvedValue({ ...mockNotification, userId: randomUUID() });
+      mockPrismaService.notification.findUnique.mockResolvedValue({
+        ...mockNotification,
+        userId: randomUUID(),
+      });
 
-      await expect(controller.update(mockNotificationId, updateDto)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(mockNotificationId, updateDto),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.update("invalid-id", updateDto)).rejects.toThrow(BadRequestException);
+      await expect(controller.update('invalid-id', updateDto)).rejects.toThrow(
+        BadRequestException,
+      );
     });
 
     it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { read: 'invalid' };
-      await expect(controller.update(mockNotificationId, invalidDto)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(mockNotificationId, invalidDto),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when notification not found', async () => {
       mockPrismaService.notification.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
   describe('remove', () => {
     it('should delete notification for ADMIN', async () => {
-      mockPrismaService.notification.findUnique.mockResolvedValue(mockNotification);
+      mockPrismaService.notification.findUnique.mockResolvedValue(
+        mockNotification,
+      );
       mockPrismaService.notification.delete.mockResolvedValue(mockNotification);
 
       const result = await controller.remove(mockNotificationId);
 
       expect(result).toEqual({ message: 'Notification deleted' });
-      expect(mockPrismaService.notification.delete).toHaveBeenCalledWith({ where: { id: mockNotificationId } });
+      expect(mockPrismaService.notification.delete).toHaveBeenCalledWith({
+        where: { id: mockNotificationId },
+      });
     });
 
     it('should delete own notification for STUDENT', async () => {
-      mockPrismaService.notification.findUnique.mockResolvedValue(mockNotification);
+      mockPrismaService.notification.findUnique.mockResolvedValue(
+        mockNotification,
+      );
       mockPrismaService.notification.delete.mockResolvedValue(mockNotification);
 
       const result = await controller.remove(mockNotificationId);
 
       expect(result).toEqual({ message: 'Notification deleted' });
-      expect(mockPrismaService.notification.delete).toHaveBeenCalledWith({ where: { id: mockNotificationId } });
+      expect(mockPrismaService.notification.delete).toHaveBeenCalledWith({
+        where: { id: mockNotificationId },
+      });
     });
 
     it('should throw ForbiddenException for STUDENT deleting other user notification', async () => {
-      mockPrismaService.notification.findUnique.mockResolvedValue({ ...mockNotification, userId: randomUUID() });
+      mockPrismaService.notification.findUnique.mockResolvedValue({
+        ...mockNotification,
+        userId: randomUUID(),
+      });
 
-      await expect(controller.remove(mockNotificationId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockNotificationId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.remove('invalid-id', mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when notification not found', async () => {
       mockPrismaService.notification.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
-});
\ No newline at end of file
+});
diff --git a/src/progress/progress.controller.spec.ts b/src/progress/progress.controller.spec.ts
index 04425ad..d61c92e 100644
--- a/src/progress/progress.controller.spec.ts
+++ b/src/progress/progress.controller.spec.ts
@@ -4,7 +4,11 @@ import { ProgressService } from './progress.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('ProgressController', () => {
   let controller: ProgressController;
@@ -89,10 +93,15 @@ describe('ProgressController', () => {
     it('should return progress by ID for ADMIN', async () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(mockProgress);
 
-      const result = await controller.findAll(mockAuthenticatedAdminRequest, mockProgressId);
+      const result = await controller.findAll(
+        mockAuthenticatedAdminRequest,
+        mockProgressId,
+      );
 
       expect(result).toEqual(mockProgress);
-      expect(mockPrismaService.progress.findUnique).toHaveBeenCalledWith({ where: { id: mockProgressId } });
+      expect(mockPrismaService.progress.findUnique).toHaveBeenCalledWith({
+        where: { id: mockProgressId },
+      });
     });
 
     it('should return own progress for STUDENT', async () => {
@@ -101,36 +110,52 @@ describe('ProgressController', () => {
       const result = await controller.findAll(mockAuthenticatedStudentRequest);
 
       expect(result).toEqual([mockProgress]);
-      expect(mockPrismaService.progress.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: mockUserId,
-        },
-      }));
+      expect(mockPrismaService.progress.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            userId: mockUserId,
+          },
+        }),
+      );
     });
 
     it('should return specific progress for STUDENT if it belongs to them', async () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(mockProgress);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockProgressId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockProgressId,
+      );
 
       expect(result).toEqual(mockProgress);
-      expect(mockPrismaService.progress.findUnique).toHaveBeenCalledWith({ where: { id: mockProgressId } });
+      expect(mockPrismaService.progress.findUnique).toHaveBeenCalledWith({
+        where: { id: mockProgressId },
+      });
     });
 
     it('should throw ForbiddenException for STUDENT accessing other user progress', async () => {
-      mockPrismaService.progress.findUnique.mockResolvedValue({ ...mockProgress, userId: randomUUID() });
+      mockPrismaService.progress.findUnique.mockResolvedValue({
+        ...mockProgress,
+        userId: randomUUID(),
+      });
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, mockProgressId)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, mockProgressId),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedAdminRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedAdminRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when progress not found', async () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedAdminRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedAdminRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -152,14 +177,16 @@ describe('ProgressController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.progress.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: filters.userId,
-          courseId: filters.courseId,
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.progress.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            userId: filters.userId,
+            courseId: filters.courseId,
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -175,51 +202,83 @@ describe('ProgressController', () => {
     it('should create progress for ADMIN', async () => {
       const createdProgress = { id: randomUUID(), ...createProgressDto };
       mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
-      mockPrismaService.course.findUnique.mockResolvedValue({ id: mockCourseId });
+      mockPrismaService.course.findUnique.mockResolvedValue({
+        id: mockCourseId,
+      });
       mockPrismaService.progress.create.mockResolvedValue(createdProgress);
 
-      const result = await controller.create(createProgressDto, mockAuthenticatedAdminRequest);
+      const result = await controller.create(
+        createProgressDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(createdProgress);
-      expect(mockPrismaService.progress.create).toHaveBeenCalledWith({ data: createProgressDto });
+      expect(mockPrismaService.progress.create).toHaveBeenCalledWith({
+        data: createProgressDto,
+      });
     });
 
     it('should create progress for STUDENT for themselves', async () => {
       const createdProgress = { id: randomUUID(), ...createProgressDto };
       mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
-      mockPrismaService.course.findUnique.mockResolvedValue({ id: mockCourseId });
+      mockPrismaService.course.findUnique.mockResolvedValue({
+        id: mockCourseId,
+      });
       mockPrismaService.progress.create.mockResolvedValue(createdProgress);
 
-      const result = await controller.create({ courseId: mockCourseId }, mockAuthenticatedStudentRequest);
+      const result = await controller.create(
+        { courseId: mockCourseId },
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual(createdProgress);
-      expect(mockPrismaService.progress.create).toHaveBeenCalledWith({ data: { userId: mockUserId, courseId: mockCourseId, completedLessons: 0, totalLessons: 0, progressPercentage: 0 } });
+      expect(mockPrismaService.progress.create).toHaveBeenCalledWith({
+        data: {
+          userId: mockUserId,
+          courseId: mockCourseId,
+          completedLessons: 0,
+          totalLessons: 0,
+          progressPercentage: 0,
+        },
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { userId: 'invalid-id', courseId: 'invalid-id' };
-      await expect(controller.create(invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for STUDENT creating progress for another user", async () => {
+    it('should throw ForbiddenException for STUDENT creating progress for another user', async () => {
       const otherUserId = randomUUID();
-      const otherStudentRequest = { user: { sub: otherUserId, role: 'STUDENT' } } as AuthenticatedRequest;
+      const otherStudentRequest = {
+        user: { sub: otherUserId, role: 'STUDENT' },
+      } as AuthenticatedRequest;
 
-      await expect(controller.create(createProgressDto, otherStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.create(createProgressDto, otherStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw NotFoundException if user not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(null);
-      mockPrismaService.course.findUnique.mockResolvedValue({ id: mockCourseId });
+      mockPrismaService.course.findUnique.mockResolvedValue({
+        id: mockCourseId,
+      });
 
-      await expect(controller.create(createProgressDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.create(createProgressDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should throw NotFoundException if course not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
       mockPrismaService.course.findUnique.mockResolvedValue(null);
 
-      await expect(controller.create(createProgressDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.create(createProgressDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -231,10 +290,17 @@ describe('ProgressController', () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(mockProgress);
       mockPrismaService.progress.update.mockResolvedValue(updatedProgress);
 
-      const result = await controller.update(mockProgressId, updateDto, mockAuthenticatedAdminRequest);
+      const result = await controller.update(
+        mockProgressId,
+        updateDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(updatedProgress);
-      expect(mockPrismaService.progress.update).toHaveBeenCalledWith({ where: { id: mockProgressId }, data: updateDto });
+      expect(mockPrismaService.progress.update).toHaveBeenCalledWith({
+        where: { id: mockProgressId },
+        data: updateDto,
+      });
     });
 
     it('should update own progress for STUDENT', async () => {
@@ -242,31 +308,65 @@ describe('ProgressController', () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(mockProgress);
       mockPrismaService.progress.update.mockResolvedValue(updatedProgress);
 
-      const result = await controller.update(mockProgressId, updateDto, mockAuthenticatedStudentRequest);
+      const result = await controller.update(
+        mockProgressId,
+        updateDto,
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual(updatedProgress);
-      expect(mockPrismaService.progress.update).toHaveBeenCalledWith({ where: { id: mockProgressId }, data: updateDto });
+      expect(mockPrismaService.progress.update).toHaveBeenCalledWith({
+        where: { id: mockProgressId },
+        data: updateDto,
+      });
     });
 
     it('should throw ForbiddenException for STUDENT updating other user progress', async () => {
-      mockPrismaService.progress.findUnique.mockResolvedValue({ ...mockProgress, userId: randomUUID() });
-
-      await expect(controller.update(mockProgressId, updateDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      mockPrismaService.progress.findUnique.mockResolvedValue({
+        ...mockProgress,
+        userId: randomUUID(),
+      });
+
+      await expect(
+        controller.update(
+          mockProgressId,
+          updateDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { completedLessons: 'invalid' };
-      await expect(controller.update(mockProgressId, invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(
+          mockProgressId,
+          invalidDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.update('invalid-id', updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when progress not found', async () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -275,36 +375,55 @@ describe('ProgressController', () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(mockProgress);
       mockPrismaService.progress.delete.mockResolvedValue(mockProgress);
 
-      const result = await controller.remove(mockProgressId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove(
+        mockProgressId,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual({ message: 'Progress deleted' });
-      expect(mockPrismaService.progress.delete).toHaveBeenCalledWith({ where: { id: mockProgressId } });
+      expect(mockPrismaService.progress.delete).toHaveBeenCalledWith({
+        where: { id: mockProgressId },
+      });
     });
 
     it('should delete own progress for STUDENT', async () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(mockProgress);
       mockPrismaService.progress.delete.mockResolvedValue(mockProgress);
 
-      const result = await controller.remove(mockProgressId, mockAuthenticatedStudentRequest);
+      const result = await controller.remove(
+        mockProgressId,
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual({ message: 'Progress deleted' });
-      expect(mockPrismaService.progress.delete).toHaveBeenCalledWith({ where: { id: mockProgressId } });
+      expect(mockPrismaService.progress.delete).toHaveBeenCalledWith({
+        where: { id: mockProgressId },
+      });
     });
 
     it('should throw ForbiddenException for STUDENT deleting other user progress', async () => {
-      mockPrismaService.progress.findUnique.mockResolvedValue({ ...mockProgress, userId: randomUUID() });
+      mockPrismaService.progress.findUnique.mockResolvedValue({
+        ...mockProgress,
+        userId: randomUUID(),
+      });
 
-      await expect(controller.remove(mockProgressId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockProgressId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when progress not found', async () => {
       mockPrismaService.progress.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
-});
\ No newline at end of file
+});
diff --git a/src/questions/questions.controller.spec.ts b/src/questions/questions.controller.spec.ts
index 2346c38..6a576a3 100644
--- a/src/questions/questions.controller.spec.ts
+++ b/src/questions/questions.controller.spec.ts
@@ -4,7 +4,11 @@ import { QuestionsService } from './questions.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('QuestionsController', () => {
   let controller: QuestionsController;
@@ -93,20 +97,30 @@ describe('QuestionsController', () => {
     it('should return question by ID for any authenticated user', async () => {
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockQuestionId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockQuestionId,
+      );
 
       expect(result).toEqual(mockQuestion);
-      expect(mockPrismaService.question.findUnique).toHaveBeenCalledWith({ where: { id: mockQuestionId }, include: { options: true, topic: true } });
+      expect(mockPrismaService.question.findUnique).toHaveBeenCalledWith({
+        where: { id: mockQuestionId },
+        include: { options: true, topic: true },
+      });
     });
 
     it('should throw BadRequestException for invalid question ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when question not found', async () => {
       mockPrismaService.question.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -131,13 +145,15 @@ describe('QuestionsController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.question.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          topicId: filters.topicId,
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.question.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            topicId: filters.topicId,
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -153,132 +169,212 @@ describe('QuestionsController', () => {
       ],
     };
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { ...createQuestionDto, text: "" };
-      await expect(controller.create(invalidDto, mockAuthenticatedProfessorRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid data', async () => {
+      const invalidDto = { ...createQuestionDto, text: '' };
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedProfessorRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should create question for PROFESSOR", async () => {
-      const createdQuestion = { id: randomUUID(), ...createQuestionDto, authorId: mockAuthorId };
+    it('should create question for PROFESSOR', async () => {
+      const createdQuestion = {
+        id: randomUUID(),
+        ...createQuestionDto,
+        authorId: mockAuthorId,
+      };
       mockPrismaService.question.create.mockResolvedValue(createdQuestion);
 
-      const result = await controller.create(createQuestionDto, mockAuthenticatedProfessorRequest);
+      const result = await controller.create(
+        createQuestionDto,
+        mockAuthenticatedProfessorRequest,
+      );
 
       expect(result).toEqual(createdQuestion);
-      expect(mockPrismaService.question.create).toHaveBeenCalledWith({ data: { ...createQuestionDto, authorId: mockAuthorId } });
+      expect(mockPrismaService.question.create).toHaveBeenCalledWith({
+        data: { ...createQuestionDto, authorId: mockAuthorId },
+      });
     });
 
     it('should create question for ADMIN', async () => {
-      const createdQuestion = { id: randomUUID(), ...createQuestionDto, authorId: mockAdminId };
+      const createdQuestion = {
+        id: randomUUID(),
+        ...createQuestionDto,
+        authorId: mockAdminId,
+      };
       mockPrismaService.question.create.mockResolvedValue(createdQuestion);
 
-      const result = await controller.create(createQuestionDto, mockAuthenticatedAdminRequest);
+      const result = await controller.create(
+        createQuestionDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(createdQuestion);
-      expect(mockPrismaService.question.create).toHaveBeenCalledWith({ data: { ...createQuestionDto, authorId: mockAdminId } });
+      expect(mockPrismaService.question.create).toHaveBeenCalledWith({
+        data: { ...createQuestionDto, authorId: mockAdminId },
+      });
     });
 
     it('should throw ForbiddenException for STUDENT', async () => {
-      await expect(controller.create(createQuestionDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.create(createQuestionDto, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { ...createQuestionDto, text: '' };
-      await expect(controller.create(invalidDto, mockAuthenticatedProfessorRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedProfessorRequest),
+      ).rejects.toThrow(BadRequestException);
     });
   });
 
-  describe("update", () => {
-    const updateDto = { text: "Updated Question" };
+  describe('update', () => {
+    const updateDto = { text: 'Updated Question' };
 
-    it("should update question for ADMIN", async () => {
+    it('should update question for ADMIN', async () => {
       const updatedQuestion = { ...mockQuestion, ...updateDto };
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
       mockPrismaService.question.update.mockResolvedValue(updatedQuestion);
 
-      const result = await controller.update(mockQuestionId, updateDto, mockAuthenticatedAdminRequest);
+      const result = await controller.update(
+        mockQuestionId,
+        updateDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(updatedQuestion);
-      expect(mockPrismaService.question.update).toHaveBeenCalledWith({ where: { id: mockQuestionId }, data: updateDto });
+      expect(mockPrismaService.question.update).toHaveBeenCalledWith({
+        where: { id: mockQuestionId },
+        data: updateDto,
+      });
     });
 
-    it("should update own question for PROFESSOR", async () => {
+    it('should update own question for PROFESSOR', async () => {
       const updatedQuestion = { ...mockQuestion, ...updateDto };
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
       mockPrismaService.question.update.mockResolvedValue(updatedQuestion);
 
-      const result = await controller.update(mockQuestionId, updateDto, mockAuthenticatedProfessorRequest);
+      const result = await controller.update(
+        mockQuestionId,
+        updateDto,
+        mockAuthenticatedProfessorRequest,
+      );
 
       expect(result).toEqual(updatedQuestion);
-      expect(mockPrismaService.question.update).toHaveBeenCalledWith({ where: { id: mockQuestionId }, data: updateDto });
+      expect(mockPrismaService.question.update).toHaveBeenCalledWith({
+        where: { id: mockQuestionId },
+        data: updateDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.update("invalid-id", updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw NotFoundException when question not found", async () => {
+    it('should throw NotFoundException when question not found', async () => {
       mockPrismaService.question.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
 
-    it("should throw ForbiddenException for PROFESSOR updating other author question", async () => {
-      const otherProfessorRequest = { user: { sub: randomUUID(), role: "PROFESSOR" } } as AuthenticatedRequest;
+    it('should throw ForbiddenException for PROFESSOR updating other author question', async () => {
+      const otherProfessorRequest = {
+        user: { sub: randomUUID(), role: 'PROFESSOR' },
+      } as AuthenticatedRequest;
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
 
-      await expect(controller.update(mockQuestionId, updateDto, otherProfessorRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(mockQuestionId, updateDto, otherProfessorRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw ForbiddenException for STUDENT", async () => {
+    it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
 
-      await expect(controller.update(mockQuestionId, updateDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(
+          mockQuestionId,
+          updateDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
-  describe("remove", () => {
-    it("should delete question for ADMIN", async () => {
+  describe('remove', () => {
+    it('should delete question for ADMIN', async () => {
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
       mockPrismaService.question.delete.mockResolvedValue(mockQuestion);
 
-      const result = await controller.remove(mockQuestionId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove(
+        mockQuestionId,
+        mockAuthenticatedAdminRequest,
+      );
 
-      expect(result).toEqual({ message: "Question deleted" });
-      expect(mockPrismaService.question.delete).toHaveBeenCalledWith({ where: { id: mockQuestionId } });
+      expect(result).toEqual({ message: 'Question deleted' });
+      expect(mockPrismaService.question.delete).toHaveBeenCalledWith({
+        where: { id: mockQuestionId },
+      });
     });
 
-    it("should delete own question for PROFESSOR", async () => {
+    it('should delete own question for PROFESSOR', async () => {
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
       mockPrismaService.question.delete.mockResolvedValue(mockQuestion);
 
-      const result = await controller.remove(mockQuestionId, mockAuthenticatedProfessorRequest);
+      const result = await controller.remove(
+        mockQuestionId,
+        mockAuthenticatedProfessorRequest,
+      );
 
-      expect(result).toEqual({ message: "Question deleted" });
-      expect(mockPrismaService.question.delete).toHaveBeenCalledWith({ where: { id: mockQuestionId } });
+      expect(result).toEqual({ message: 'Question deleted' });
+      expect(mockPrismaService.question.delete).toHaveBeenCalledWith({
+        where: { id: mockQuestionId },
+      });
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw NotFoundException when question not found", async () => {
+    it('should throw NotFoundException when question not found', async () => {
       mockPrismaService.question.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
 
-    it("should throw ForbiddenException for PROFESSOR deleting other author question", async () => {
-      const otherProfessorRequest = { user: { sub: randomUUID(), role: "PROFESSOR" } } as AuthenticatedRequest;
+    it('should throw ForbiddenException for PROFESSOR deleting other author question', async () => {
+      const otherProfessorRequest = {
+        user: { sub: randomUUID(), role: 'PROFESSOR' },
+      } as AuthenticatedRequest;
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
 
-      await expect(controller.remove(mockQuestionId, otherProfessorRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockQuestionId, otherProfessorRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw ForbiddenException for STUDENT", async () => {
+    it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.question.findUnique.mockResolvedValue(mockQuestion);
 
-      await expect(controller.remove(mockQuestionId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockQuestionId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 });
diff --git a/src/reviews/reviews.controller.spec.ts b/src/reviews/reviews.controller.spec.ts
index 4f39ffc..275e153 100644
--- a/src/reviews/reviews.controller.spec.ts
+++ b/src/reviews/reviews.controller.spec.ts
@@ -4,7 +4,11 @@ import { ReviewsService } from './reviews.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('ReviewsController', () => {
   let controller: ReviewsController;
@@ -89,20 +93,29 @@ describe('ReviewsController', () => {
     it('should return review by ID for any authenticated user', async () => {
       mockPrismaService.review.findUnique.mockResolvedValue(mockReview);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockReviewId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockReviewId,
+      );
 
       expect(result).toEqual(mockReview);
-      expect(mockPrismaService.review.findUnique).toHaveBeenCalledWith({ where: { id: mockReviewId } });
+      expect(mockPrismaService.review.findUnique).toHaveBeenCalledWith({
+        where: { id: mockReviewId },
+      });
     });
 
     it('should throw BadRequestException for invalid review ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when review not found', async () => {
       mockPrismaService.review.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -126,15 +139,17 @@ describe('ReviewsController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.review.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: filters.userId,
-          courseId: filters.courseId,
-          rating: parseInt(filters.rating),
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.review.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            userId: filters.userId,
+            courseId: filters.courseId,
+            rating: parseInt(filters.rating),
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -147,41 +162,64 @@ describe('ReviewsController', () => {
     };
 
     it('should create review for STUDENT for themselves', async () => {
-      const createdReview = { id: randomUUID(), ...createReviewDto, createdAt: new Date() };
+      const createdReview = {
+        id: randomUUID(),
+        ...createReviewDto,
+        createdAt: new Date(),
+      };
       mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
-      mockPrismaService.course.findUnique.mockResolvedValue({ id: mockCourseId });
+      mockPrismaService.course.findUnique.mockResolvedValue({
+        id: mockCourseId,
+      });
       mockPrismaService.review.create.mockResolvedValue(createdReview);
 
-      const result = await controller.create(createReviewDto, mockAuthenticatedStudentRequest);
+      const result = await controller.create(
+        createReviewDto,
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual(createdReview);
-      expect(mockPrismaService.review.create).toHaveBeenCalledWith({ data: createReviewDto });
+      expect(mockPrismaService.review.create).toHaveBeenCalledWith({
+        data: createReviewDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { ...createReviewDto, rating: 6 };
-      await expect(controller.create(invalidDto, mockAuthenticatedStudentRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for STUDENT creating review for another user", async () => {
+    it('should throw ForbiddenException for STUDENT creating review for another user', async () => {
       const otherUserId = randomUUID();
-      const otherStudentRequest = { user: { sub: otherUserId, role: "STUDENT" } } as AuthenticatedRequest;
+      const otherStudentRequest = {
+        user: { sub: otherUserId, role: 'STUDENT' },
+      } as AuthenticatedRequest;
 
-      await expect(controller.create(createReviewDto, otherStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.create(createReviewDto, otherStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw NotFoundException if user not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(null);
-      mockPrismaService.course.findUnique.mockResolvedValue({ id: mockCourseId });
+      mockPrismaService.course.findUnique.mockResolvedValue({
+        id: mockCourseId,
+      });
 
-      await expect(controller.create(createReviewDto, mockAuthenticatedStudentRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.create(createReviewDto, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should throw NotFoundException if course not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
       mockPrismaService.course.findUnique.mockResolvedValue(null);
 
-      await expect(controller.create(createReviewDto, mockAuthenticatedStudentRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.create(createReviewDto, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -196,7 +234,10 @@ describe('ReviewsController', () => {
       const result = await controller.update(mockReviewId, updateDto);
 
       expect(result).toEqual(updatedReview);
-      expect(mockPrismaService.review.update).toHaveBeenCalledWith({ where: { id: mockReviewId }, data: updateDto });
+      expect(mockPrismaService.review.update).toHaveBeenCalledWith({
+        where: { id: mockReviewId },
+        data: updateDto,
+      });
     });
 
     it('should update own review for STUDENT', async () => {
@@ -207,28 +248,58 @@ describe('ReviewsController', () => {
       const result = await controller.update(mockReviewId, updateDto);
 
       expect(result).toEqual(updatedReview);
-      expect(mockPrismaService.review.update).toHaveBeenCalledWith({ where: { id: mockReviewId }, data: updateDto });
+      expect(mockPrismaService.review.update).toHaveBeenCalledWith({
+        where: { id: mockReviewId },
+        data: updateDto,
+      });
     });
 
     it('should throw ForbiddenException for STUDENT updating other user review', async () => {
-      mockPrismaService.review.findUnique.mockResolvedValue({ ...mockReview, userId: randomUUID() });
-
-      await expect(controller.update(mockReviewId, updateDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      mockPrismaService.review.findUnique.mockResolvedValue({
+        ...mockReview,
+        userId: randomUUID(),
+      });
+
+      await expect(
+        controller.update(
+          mockReviewId,
+          updateDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { rating: 6 };
-      await expect(controller.update(mockReviewId, invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(
+          mockReviewId,
+          invalidDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.update("invalid-id", updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when review not found', async () => {
       mockPrismaService.review.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -240,7 +311,9 @@ describe('ReviewsController', () => {
       const result = await controller.remove(mockReviewId);
 
       expect(result).toEqual({ message: 'Review deleted' });
-      expect(mockPrismaService.review.delete).toHaveBeenCalledWith({ where: { id: mockReviewId } });
+      expect(mockPrismaService.review.delete).toHaveBeenCalledWith({
+        where: { id: mockReviewId },
+      });
     });
 
     it('should delete own review for STUDENT', async () => {
@@ -250,23 +323,34 @@ describe('ReviewsController', () => {
       const result = await controller.remove(mockReviewId);
 
       expect(result).toEqual({ message: 'Review deleted' });
-      expect(mockPrismaService.review.delete).toHaveBeenCalledWith({ where: { id: mockReviewId } });
+      expect(mockPrismaService.review.delete).toHaveBeenCalledWith({
+        where: { id: mockReviewId },
+      });
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for STUDENT deleting other user review", async () => {
-      mockPrismaService.review.findUnique.mockResolvedValue({ ...mockReview, userId: randomUUID() });
+    it('should throw ForbiddenException for STUDENT deleting other user review', async () => {
+      mockPrismaService.review.findUnique.mockResolvedValue({
+        ...mockReview,
+        userId: randomUUID(),
+      });
 
-      await expect(controller.remove(mockReviewId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockReviewId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw NotFoundException when review not found', async () => {
       mockPrismaService.review.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
-});
\ No newline at end of file
+});
diff --git a/src/tags/tags.controller.spec.ts b/src/tags/tags.controller.spec.ts
index bf54e30..fb85e1e 100644
--- a/src/tags/tags.controller.spec.ts
+++ b/src/tags/tags.controller.spec.ts
@@ -4,7 +4,11 @@ import { TagsService } from './tags.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('TagsController', () => {
   let controller: TagsController;
@@ -85,20 +89,29 @@ describe('TagsController', () => {
     it('should return tag by ID for any authenticated user', async () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(mockTag);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockTagId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockTagId,
+      );
 
       expect(result).toEqual(mockTag);
-      expect(mockPrismaService.tag.findUnique).toHaveBeenCalledWith({ where: { id: mockTagId } });
+      expect(mockPrismaService.tag.findUnique).toHaveBeenCalledWith({
+        where: { id: mockTagId },
+      });
     });
 
     it('should throw BadRequestException for invalid tag ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when tag not found', async () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -118,13 +131,15 @@ describe('TagsController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.tag.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          name: { contains: filters.name, mode: 'insensitive' },
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.tag.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            name: { contains: filters.name, mode: 'insensitive' },
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -137,19 +152,28 @@ describe('TagsController', () => {
       const createdTag = { id: randomUUID(), ...createTagDto };
       mockPrismaService.tag.create.mockResolvedValue(createdTag);
 
-      const result = await controller.create(createTagDto, mockAuthenticatedAdminRequest);
+      const result = await controller.create(
+        createTagDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(createdTag);
-      expect(mockPrismaService.tag.create).toHaveBeenCalledWith({ data: createTagDto });
+      expect(mockPrismaService.tag.create).toHaveBeenCalledWith({
+        data: createTagDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { name: '' };
-      await expect(controller.create(invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for PROFESSOR", async () => {
-      await expect(controller.create(createTagDto, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+    it('should throw ForbiddenException for PROFESSOR', async () => {
+      await expect(
+        controller.create(createTagDto, mockAuthenticatedProfessorRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
@@ -161,37 +185,70 @@ describe('TagsController', () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(mockTag);
       mockPrismaService.tag.update.mockResolvedValue(updatedTag);
 
-      const result = await controller.update(mockTagId, updateDto, mockAuthenticatedAdminRequest);
+      const result = await controller.update(
+        mockTagId,
+        updateDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(updatedTag);
-      expect(mockPrismaService.tag.update).toHaveBeenCalledWith({ where: { id: mockTagId }, data: updateDto });
+      expect(mockPrismaService.tag.update).toHaveBeenCalledWith({
+        where: { id: mockTagId },
+        data: updateDto,
+      });
     });
 
     it('should throw ForbiddenException for PROFESSOR', async () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(mockTag);
 
-      await expect(controller.update(mockTagId, updateDto, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(
+          mockTagId,
+          updateDto,
+          mockAuthenticatedProfessorRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(mockTag);
 
-      await expect(controller.update(mockTagId, updateDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(
+          mockTagId,
+          updateDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { name: '' };
-      await expect(controller.update(mockTagId, invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(mockTagId, invalidDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.update('invalid-id', updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when tag not found', async () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -200,32 +257,45 @@ describe('TagsController', () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(mockTag);
       mockPrismaService.tag.delete.mockResolvedValue(mockTag);
 
-      const result = await controller.remove(mockTagId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove(
+        mockTagId,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual({ message: 'Tag deleted' });
-      expect(mockPrismaService.tag.delete).toHaveBeenCalledWith({ where: { id: mockTagId } });
+      expect(mockPrismaService.tag.delete).toHaveBeenCalledWith({
+        where: { id: mockTagId },
+      });
     });
 
     it('should throw ForbiddenException for PROFESSOR', async () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(mockTag);
 
-      await expect(controller.remove(mockTagId, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockTagId, mockAuthenticatedProfessorRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(mockTag);
 
-      await expect(controller.remove(mockTagId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockTagId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when tag not found', async () => {
       mockPrismaService.tag.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
-});
\ No newline at end of file
+});
diff --git a/src/technologies/technologies.controller.spec.ts b/src/technologies/technologies.controller.spec.ts
index 4eb8654..4ace184 100644
--- a/src/technologies/technologies.controller.spec.ts
+++ b/src/technologies/technologies.controller.spec.ts
@@ -4,7 +4,11 @@ import { TechnologiesService } from './technologies.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('TechnologiesController', () => {
   let controller: TechnologiesController;
@@ -85,20 +89,29 @@ describe('TechnologiesController', () => {
     it('should return technology by ID for any authenticated user', async () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(mockTechnology);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockTechnologyId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockTechnologyId,
+      );
 
       expect(result).toEqual(mockTechnology);
-      expect(mockPrismaService.technology.findUnique).toHaveBeenCalledWith({ where: { id: mockTechnologyId } });
+      expect(mockPrismaService.technology.findUnique).toHaveBeenCalledWith({
+        where: { id: mockTechnologyId },
+      });
     });
 
     it('should throw BadRequestException for invalid technology ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when technology not found', async () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -118,13 +131,15 @@ describe('TechnologiesController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.technology.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          name: { contains: filters.name, mode: 'insensitive' },
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.technology.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            name: { contains: filters.name, mode: 'insensitive' },
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -137,19 +152,31 @@ describe('TechnologiesController', () => {
       const createdTechnology = { id: randomUUID(), ...createTechnologyDto };
       mockPrismaService.technology.create.mockResolvedValue(createdTechnology);
 
-      const result = await controller.create(createTechnologyDto, mockAuthenticatedAdminRequest);
+      const result = await controller.create(
+        createTechnologyDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(createdTechnology);
-      expect(mockPrismaService.technology.create).toHaveBeenCalledWith({ data: createTechnologyDto });
+      expect(mockPrismaService.technology.create).toHaveBeenCalledWith({
+        data: createTechnologyDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { name: "" };
-      await expect(controller.create(invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid data', async () => {
+      const invalidDto = { name: '' };
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for PROFESSOR", async () => {
-      await expect(controller.create(createTechnologyDto, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+    it('should throw ForbiddenException for PROFESSOR', async () => {
+      await expect(
+        controller.create(
+          createTechnologyDto,
+          mockAuthenticatedProfessorRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
@@ -161,31 +188,62 @@ describe('TechnologiesController', () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(mockTechnology);
       mockPrismaService.technology.update.mockResolvedValue(updatedTechnology);
 
-      const result = await controller.update(mockTechnologyId, updateDto, mockAuthenticatedAdminRequest);
+      const result = await controller.update(
+        mockTechnologyId,
+        updateDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(updatedTechnology);
-      expect(mockPrismaService.technology.update).toHaveBeenCalledWith({ where: { id: mockTechnologyId }, data: updateDto });
+      expect(mockPrismaService.technology.update).toHaveBeenCalledWith({
+        where: { id: mockTechnologyId },
+        data: updateDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { name: "" };
-      await expect(controller.update(mockTechnologyId, invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid data', async () => {
+      const invalidDto = { name: '' };
+      await expect(
+        controller.update(
+          mockTechnologyId,
+          invalidDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.update("invalid-id", updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for PROFESSOR", async () => {
+    it('should throw ForbiddenException for PROFESSOR', async () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(mockTechnology);
 
-      await expect(controller.update(mockTechnologyId, updateDto, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(
+          mockTechnologyId,
+          updateDto,
+          mockAuthenticatedProfessorRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw NotFoundException when technology not found', async () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -194,33 +252,45 @@ describe('TechnologiesController', () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(mockTechnology);
       mockPrismaService.technology.delete.mockResolvedValue(mockTechnology);
 
-      const result = await controller.remove(mockTechnologyId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove(
+        mockTechnologyId,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual({ message: 'Technology deleted' });
-      expect(mockPrismaService.technology.delete).toHaveBeenCalledWith({ where: { id: mockTechnologyId } });
+      expect(mockPrismaService.technology.delete).toHaveBeenCalledWith({
+        where: { id: mockTechnologyId },
+      });
     });
 
     it('should throw ForbiddenException for PROFESSOR', async () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(mockTechnology);
 
-      await expect(controller.remove(mockTechnologyId, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockTechnologyId, mockAuthenticatedProfessorRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(mockTechnology);
 
-      await expect(controller.remove(mockTechnologyId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockTechnologyId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when technology not found', async () => {
       mockPrismaService.technology.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 });
-
diff --git a/src/topics/topics.controller.spec.ts b/src/topics/topics.controller.spec.ts
index c9cfab5..22072ae 100644
--- a/src/topics/topics.controller.spec.ts
+++ b/src/topics/topics.controller.spec.ts
@@ -4,7 +4,11 @@ import { TopicsService } from './topics.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('TopicsController', () => {
   let controller: TopicsController;
@@ -85,20 +89,29 @@ describe('TopicsController', () => {
     it('should return topic by ID for any authenticated user', async () => {
       mockPrismaService.topic.findUnique.mockResolvedValue(mockTopic);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockTopicId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockTopicId,
+      );
 
       expect(result).toEqual(mockTopic);
-      expect(mockPrismaService.topic.findUnique).toHaveBeenCalledWith({ where: { id: mockTopicId } });
+      expect(mockPrismaService.topic.findUnique).toHaveBeenCalledWith({
+        where: { id: mockTopicId },
+      });
     });
 
     it('should throw BadRequestException for invalid topic ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when topic not found', async () => {
       mockPrismaService.topic.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -118,13 +131,15 @@ describe('TopicsController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.topic.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          name: { contains: filters.name, mode: 'insensitive' },
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(mockPrismaService.topic.findMany).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            name: { contains: filters.name, mode: 'insensitive' },
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -137,19 +152,28 @@ describe('TopicsController', () => {
       const createdTopic = { id: randomUUID(), ...createTopicDto };
       mockPrismaService.topic.create.mockResolvedValue(createdTopic);
 
-      const result = await controller.create(createTopicDto, mockAuthenticatedAdminRequest);
+      const result = await controller.create(
+        createTopicDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(createdTopic);
-      expect(mockPrismaService.topic.create).toHaveBeenCalledWith({ data: createTopicDto });
+      expect(mockPrismaService.topic.create).toHaveBeenCalledWith({
+        data: createTopicDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { name: "" };
-      await expect(controller.create(invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid data', async () => {
+      const invalidDto = { name: '' };
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for PROFESSOR", async () => {
-      await expect(controller.create(createTopicDto, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+    it('should throw ForbiddenException for PROFESSOR', async () => {
+      await expect(
+        controller.create(createTopicDto, mockAuthenticatedProfessorRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
@@ -161,31 +185,62 @@ describe('TopicsController', () => {
       mockPrismaService.topic.findUnique.mockResolvedValue(mockTopic);
       mockPrismaService.topic.update.mockResolvedValue(updatedTopic);
 
-      const result = await controller.update(mockTopicId, updateDto, mockAuthenticatedAdminRequest);
+      const result = await controller.update(
+        mockTopicId,
+        updateDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(updatedTopic);
-      expect(mockPrismaService.topic.update).toHaveBeenCalledWith({ where: { id: mockTopicId }, data: updateDto });
+      expect(mockPrismaService.topic.update).toHaveBeenCalledWith({
+        where: { id: mockTopicId },
+        data: updateDto,
+      });
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { name: '' };
-      await expect(controller.update(mockTopicId, invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(
+          mockTopicId,
+          invalidDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.update('invalid-id', updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw ForbiddenException for PROFESSOR', async () => {
       mockPrismaService.topic.findUnique.mockResolvedValue(mockTopic);
 
-      await expect(controller.update(mockTopicId, updateDto, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(
+          mockTopicId,
+          updateDto,
+          mockAuthenticatedProfessorRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw ForbiddenException for STUDENT', async () => {
       mockPrismaService.topic.findUnique.mockResolvedValue(mockTopic);
 
-      await expect(controller.update(mockTopicId, updateDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.update(
+          mockTopicId,
+          updateDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
@@ -194,21 +249,29 @@ describe('TopicsController', () => {
       mockPrismaService.topic.findUnique.mockResolvedValue(mockTopic);
       mockPrismaService.topic.delete.mockResolvedValue(mockTopic);
 
-      const result = await controller.remove(mockTopicId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove(
+        mockTopicId,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual({ message: 'Topic deleted' });
-      expect(mockPrismaService.topic.delete).toHaveBeenCalledWith({ where: { id: mockTopicId } });
+      expect(mockPrismaService.topic.delete).toHaveBeenCalledWith({
+        where: { id: mockTopicId },
+      });
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw ForbiddenException for PROFESSOR", async () => {
+    it('should throw ForbiddenException for PROFESSOR', async () => {
       mockPrismaService.topic.findUnique.mockResolvedValue(mockTopic);
 
-      await expect(controller.remove(mockTopicId, mockAuthenticatedProfessorRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.remove(mockTopicId, mockAuthenticatedProfessorRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 });
-
diff --git a/src/user-topic-performance/user-topic-performance.controller.spec.ts b/src/user-topic-performance/user-topic-performance.controller.spec.ts
index 4189fb2..b35f707 100644
--- a/src/user-topic-performance/user-topic-performance.controller.spec.ts
+++ b/src/user-topic-performance/user-topic-performance.controller.spec.ts
@@ -4,7 +4,11 @@ import { UserTopicPerformanceService } from './user-topic-performance.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('UserTopicPerformanceController', () => {
   let controller: UserTopicPerformanceController;
@@ -65,8 +69,12 @@ describe('UserTopicPerformanceController', () => {
       ],
     }).compile();
 
-    controller = module.get<UserTopicPerformanceController>(UserTopicPerformanceController);
-    service = module.get<UserTopicPerformanceService>(UserTopicPerformanceService);
+    controller = module.get<UserTopicPerformanceController>(
+      UserTopicPerformanceController,
+    );
+    service = module.get<UserTopicPerformanceService>(
+      UserTopicPerformanceService,
+    );
   });
 
   afterEach(() => {
@@ -79,31 +87,46 @@ describe('UserTopicPerformanceController', () => {
 
   describe('findAll', () => {
     it('should return a list of user topic performances for any authenticated user', async () => {
-      mockPrismaService.userTopicPerformance.findMany.mockResolvedValue([mockUserTopicPerformance]);
+      mockPrismaService.userTopicPerformance.findMany.mockResolvedValue([
+        mockUserTopicPerformance,
+      ]);
 
       const result = await controller.findAll(mockAuthenticatedStudentRequest);
 
       expect(result).toEqual([mockUserTopicPerformance]);
-      expect(mockPrismaService.userTopicPerformance.findMany).toHaveBeenCalledTimes(1);
+      expect(
+        mockPrismaService.userTopicPerformance.findMany,
+      ).toHaveBeenCalledTimes(1);
     });
 
     it('should return user topic performance by ID for any authenticated user', async () => {
-      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(mockUserTopicPerformance);
+      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(
+        mockUserTopicPerformance,
+      );
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockUserTopicPerformanceId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockUserTopicPerformanceId,
+      );
 
       expect(result).toEqual(mockUserTopicPerformance);
-      expect(mockPrismaService.userTopicPerformance.findUnique).toHaveBeenCalledWith({ where: { id: mockUserTopicPerformanceId } });
+      expect(
+        mockPrismaService.userTopicPerformance.findUnique,
+      ).toHaveBeenCalledWith({ where: { id: mockUserTopicPerformanceId } });
     });
 
     it('should throw BadRequestException for invalid user topic performance ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when user topic performance not found', async () => {
       mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedStudentRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should apply filters when provided', async () => {
@@ -125,14 +148,18 @@ describe('UserTopicPerformanceController', () => {
         filters.offset,
       );
 
-      expect(mockPrismaService.userTopicPerformance.findMany).toHaveBeenCalledWith(expect.objectContaining({
-        where: {
-          userId: filters.userId,
-          topicId: filters.topicId,
-        },
-        take: 10,
-        skip: 0,
-      }));
+      expect(
+        mockPrismaService.userTopicPerformance.findMany,
+      ).toHaveBeenCalledWith(
+        expect.objectContaining({
+          where: {
+            userId: filters.userId,
+            topicId: filters.topicId,
+          },
+          take: 10,
+          skip: 0,
+        }),
+      );
     });
   });
 
@@ -145,41 +172,75 @@ describe('UserTopicPerformanceController', () => {
     };
 
     it('should create user topic performance for STUDENT for themselves', async () => {
-      const createdUserTopicPerformance = { id: randomUUID(), ...createUserTopicPerformanceDto, accuracy: 0.5, lastAttempt: new Date() };
+      const createdUserTopicPerformance = {
+        id: randomUUID(),
+        ...createUserTopicPerformanceDto,
+        accuracy: 0.5,
+        lastAttempt: new Date(),
+      };
       mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
       mockPrismaService.topic.findUnique.mockResolvedValue({ id: mockTopicId });
-      mockPrismaService.userTopicPerformance.create.mockResolvedValue(createdUserTopicPerformance);
+      mockPrismaService.userTopicPerformance.create.mockResolvedValue(
+        createdUserTopicPerformance,
+      );
 
-      const result = await controller.create(createUserTopicPerformanceDto, mockAuthenticatedStudentRequest);
+      const result = await controller.create(
+        createUserTopicPerformanceDto,
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual(createdUserTopicPerformance);
-      expect(mockPrismaService.userTopicPerformance.create).toHaveBeenCalledWith({ data: expect.objectContaining(createUserTopicPerformance) });
+      expect(
+        mockPrismaService.userTopicPerformance.create,
+      ).toHaveBeenCalledWith({
+        data: expect.objectContaining(createUserTopicPerformance),
+      });
     });
 
     it('should throw ForbiddenException for STUDENT creating user topic performance for another user', async () => {
       const otherUserId = randomUUID();
-      const otherStudentRequest = { user: { sub: otherUserId, role: 'STUDENT' } } as AuthenticatedRequest;
+      const otherStudentRequest = {
+        user: { sub: otherUserId, role: 'STUDENT' },
+      } as AuthenticatedRequest;
 
-      await expect(controller.create(createUserTopicPerformanceDto, otherStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.create(createUserTopicPerformanceDto, otherStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid data', async () => {
-      const invalidDto = { ...createUserTopicPerformanceDto, correctAnswers: 15, totalQuestions: 10 };
-      await expect(controller.create(invalidDto, mockAuthenticatedStudentRequest)).rejects.toThrow(BadRequestException);
+      const invalidDto = {
+        ...createUserTopicPerformanceDto,
+        correctAnswers: 15,
+        totalQuestions: 10,
+      };
+      await expect(
+        controller.create(invalidDto, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException if user not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(null);
       mockPrismaService.topic.findUnique.mockResolvedValue({ id: mockTopicId });
 
-      await expect(controller.create(createUserTopicPerformanceDto, mockAuthenticatedStudentRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.create(
+          createUserTopicPerformanceDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
 
     it('should throw NotFoundException if topic not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue({ id: mockUserId });
       mockPrismaService.topic.findUnique.mockResolvedValue(null);
 
-      await expect(controller.create(createUserTopicPerformanceDto, mockAuthenticatedStudentRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.create(
+          createUserTopicPerformanceDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -187,85 +248,175 @@ describe('UserTopicPerformanceController', () => {
     const updateDto = { correctAnswers: 12, totalQuestions: 15 };
 
     it('should update user topic performance for ADMIN', async () => {
-      const updatedUserTopicPerformance = { ...mockUserTopicPerformance, ...updateDto, accuracy: 0.8 };
-      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(mockUserTopicPerformance);
-      mockPrismaService.userTopicPerformance.update.mockResolvedValue(updatedUserTopicPerformance);
+      const updatedUserTopicPerformance = {
+        ...mockUserTopicPerformance,
+        ...updateDto,
+        accuracy: 0.8,
+      };
+      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(
+        mockUserTopicPerformance,
+      );
+      mockPrismaService.userTopicPerformance.update.mockResolvedValue(
+        updatedUserTopicPerformance,
+      );
 
-      const result = await controller.update(mockUserTopicPerformanceId, updateDto, mockAuthenticatedAdminRequest);
+      const result = await controller.update(
+        mockUserTopicPerformanceId,
+        updateDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(updatedUserTopicPerformance);
-      expect(mockPrismaService.userTopicPerformance.update).toHaveBeenCalledWith({ where: { id: mockUserTopicPerformanceId }, data: expect.objectContaining(updateDto) });
+      expect(
+        mockPrismaService.userTopicPerformance.update,
+      ).toHaveBeenCalledWith({
+        where: { id: mockUserTopicPerformanceId },
+        data: expect.objectContaining(updateDto),
+      });
     });
 
     it('should update own user topic performance for STUDENT', async () => {
-      const updatedUserTopicPerformance = { ...mockUserTopicPerformance, ...updateDto, accuracy: 0.8 };
-      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(mockUserTopicPerformance);
-      mockPrismaService.userTopicPerformance.update.mockResolvedValue(updatedUserTopicPerformance);
+      const updatedUserTopicPerformance = {
+        ...mockUserTopicPerformance,
+        ...updateDto,
+        accuracy: 0.8,
+      };
+      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(
+        mockUserTopicPerformance,
+      );
+      mockPrismaService.userTopicPerformance.update.mockResolvedValue(
+        updatedUserTopicPerformance,
+      );
 
-      const result = await controller.update(mockUserTopicPerformanceId, updateDto, mockAuthenticatedStudentRequest);
+      const result = await controller.update(
+        mockUserTopicPerformanceId,
+        updateDto,
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual(updatedUserTopicPerformance);
-      expect(mockPrismaService.userTopicPerformance.update).toHaveBeenCalledWith({ where: { id: mockUserTopicPerformanceId }, data: expect.objectContaining(updateDto) });
+      expect(
+        mockPrismaService.userTopicPerformance.update,
+      ).toHaveBeenCalledWith({
+        where: { id: mockUserTopicPerformanceId },
+        data: expect.objectContaining(updateDto),
+      });
     });
 
     it('should throw ForbiddenException for STUDENT updating other user topic performance', async () => {
-      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue({ ...mockUserTopicPerformance, userId: randomUUID() });
-
-      await expect(controller.update(mockUserTopicPerformanceId, updateDto, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue({
+        ...mockUserTopicPerformance,
+        userId: randomUUID(),
+      });
+
+      await expect(
+        controller.update(
+          mockUserTopicPerformanceId,
+          updateDto,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.update('invalid-id', updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = { correctAnswers: 20, totalQuestions: 10 };
-      await expect(controller.update(mockUserTopicPerformanceId, invalidDto, mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.update(
+          mockUserTopicPerformanceId,
+          invalidDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when user topic performance not found', async () => {
       mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
   describe('remove', () => {
     it('should delete user topic performance for ADMIN', async () => {
-      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(mockUserTopicPerformance);
-      mockPrismaService.userTopicPerformance.delete.mockResolvedValue(mockUserTopicPerformance);
+      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(
+        mockUserTopicPerformance,
+      );
+      mockPrismaService.userTopicPerformance.delete.mockResolvedValue(
+        mockUserTopicPerformance,
+      );
 
-      const result = await controller.remove(mockUserTopicPerformanceId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove(
+        mockUserTopicPerformanceId,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual({ message: 'User topic performance deleted' });
-      expect(mockPrismaService.userTopicPerformance.delete).toHaveBeenCalledWith({ where: { id: mockUserTopicPerformanceId } });
+      expect(
+        mockPrismaService.userTopicPerformance.delete,
+      ).toHaveBeenCalledWith({ where: { id: mockUserTopicPerformanceId } });
     });
 
     it('should delete own user topic performance for STUDENT', async () => {
-      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(mockUserTopicPerformance);
-      mockPrismaService.userTopicPerformance.delete.mockResolvedValue(mockUserTopicPerformance);
+      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(
+        mockUserTopicPerformance,
+      );
+      mockPrismaService.userTopicPerformance.delete.mockResolvedValue(
+        mockUserTopicPerformance,
+      );
 
-      const result = await controller.remove(mockUserTopicPerformanceId, mockAuthenticatedStudentRequest);
+      const result = await controller.remove(
+        mockUserTopicPerformanceId,
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual({ message: 'User topic performance deleted' });
-      expect(mockPrismaService.userTopicPerformance.delete).toHaveBeenCalledWith({ where: { id: mockUserTopicPerformanceId } });
+      expect(
+        mockPrismaService.userTopicPerformance.delete,
+      ).toHaveBeenCalledWith({ where: { id: mockUserTopicPerformanceId } });
     });
 
     it('should throw ForbiddenException for STUDENT deleting other user topic performance', async () => {
-      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue({ ...mockUserTopicPerformance, userId: randomUUID() });
-
-      await expect(controller.remove(mockUserTopicPerformanceId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue({
+        ...mockUserTopicPerformance,
+        userId: randomUUID(),
+      });
+
+      await expect(
+        controller.remove(
+          mockUserTopicPerformanceId,
+          mockAuthenticatedStudentRequest,
+        ),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.remove('invalid-id', mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when user topic performance not found', async () => {
       mockPrismaService.userTopicPerformance.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 });
-
diff --git a/src/users/users.controller.spec.ts b/src/users/users.controller.spec.ts
index 4f24e2f..9ba9467 100644
--- a/src/users/users.controller.spec.ts
+++ b/src/users/users.controller.spec.ts
@@ -4,7 +4,11 @@ import { UsersService } from './users.service';
 import { PrismaService } from '../prisma/prisma.service';
 import { randomUUID } from 'crypto';
 import { AuthenticatedRequest } from '../common/interfaces/authenticated-request.interface';
-import { BadRequestException, ForbiddenException, NotFoundException } from '@nestjs/common';
+import {
+  BadRequestException,
+  ForbiddenException,
+  NotFoundException,
+} from '@nestjs/common';
 
 describe('UsersController', () => {
   let controller: UsersController;
@@ -76,7 +80,10 @@ describe('UsersController', () => {
 
   describe('findAll', () => {
     it('should return a list of users for ADMIN', async () => {
-      mockPrismaService.user.findMany.mockResolvedValue([mockUser, mockAdminUser]);
+      mockPrismaService.user.findMany.mockResolvedValue([
+        mockUser,
+        mockAdminUser,
+      ]);
 
       const result = await controller.findAll(mockAuthenticatedAdminRequest);
 
@@ -87,19 +94,29 @@ describe('UsersController', () => {
     it('should return user by ID for ADMIN', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
 
-      const result = await controller.findAll(mockAuthenticatedAdminRequest, mockUserId);
+      const result = await controller.findAll(
+        mockAuthenticatedAdminRequest,
+        mockUserId,
+      );
 
       expect(result).toEqual(mockUser);
-      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({ where: { id: mockUserId } });
+      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({
+        where: { id: mockUserId },
+      });
     });
 
     it('should return own profile for STUDENT', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
 
-      const result = await controller.findAll(mockAuthenticatedStudentRequest, mockUserId);
+      const result = await controller.findAll(
+        mockAuthenticatedStudentRequest,
+        mockUserId,
+      );
 
       expect(result).toEqual(mockUser);
-      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({ where: { id: mockUserId } });
+      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({
+        where: { id: mockUserId },
+      });
     });
 
     it('should throw ForbiddenException for STUDENT accessing other user profile', async () => {
@@ -109,17 +126,23 @@ describe('UsersController', () => {
     });
 
     it('should throw ForbiddenException for non-ADMIN listing all users', async () => {
-      await expect(controller.findAll(mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+      await expect(
+        controller.findAll(mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
 
     it('should throw BadRequestException for invalid ID', async () => {
-      await expect(controller.findAll(mockAuthenticatedAdminRequest, 'invalid-id')).rejects.toThrow(BadRequestException);
+      await expect(
+        controller.findAll(mockAuthenticatedAdminRequest, 'invalid-id'),
+      ).rejects.toThrow(BadRequestException);
     });
 
     it('should throw NotFoundException when user not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(null);
 
-      await expect(controller.findAll(mockAuthenticatedAdminRequest, randomUUID())).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.findAll(mockAuthenticatedAdminRequest, randomUUID()),
+      ).rejects.toThrow(NotFoundException);
     });
   });
 
@@ -131,25 +154,29 @@ describe('UsersController', () => {
       role: 'STUDENT',
     };
 
-    it("should throw BadRequestException for invalid data", async () => {
+    it('should throw BadRequestException for invalid data', async () => {
       const invalidDto = {
-        name: "",
-        email: "invalid-email",
-        password: "123",
-        role: "INVALID_ROLE",
+        name: '',
+        email: 'invalid-email',
+        password: '123',
+        role: 'INVALID_ROLE',
       };
 
-      await expect(controller.create(invalidDto)).rejects.toThrow(BadRequestException);
+      await expect(controller.create(invalidDto)).rejects.toThrow(
+        BadRequestException,
+      );
     });
 
-    it("should create user for ADMIN", async () => {
+    it('should create user for ADMIN', async () => {
       const createdUser = { id: randomUUID(), ...createUserDto };
       mockPrismaService.user.create.mockResolvedValue(createdUser);
 
       const result = await controller.create(createUserDto);
 
       expect(result).toEqual(createdUser);
-      expect(mockPrismaService.user.create).toHaveBeenCalledWith({ data: createUserDto });
+      expect(mockPrismaService.user.create).toHaveBeenCalledWith({
+        data: createUserDto,
+      });
     });
 
     it('should throw BadRequestException for invalid data', async () => {
@@ -160,7 +187,9 @@ describe('UsersController', () => {
         role: 'INVALID_ROLE',
       };
 
-      await expect(controller.create(invalidDto)).rejects.toThrow(BadRequestException);
+      await expect(controller.create(invalidDto)).rejects.toThrow(
+        BadRequestException,
+      );
     });
   });
 
@@ -172,7 +201,11 @@ describe('UsersController', () => {
       mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
       mockPrismaService.user.update.mockResolvedValue(updatedUser);
 
-      const result = await controller.update(mockUserId, updateDto, mockAuthenticatedAdminRequest);
+      const result = await controller.update(
+        mockUserId,
+        updateDto,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual(updatedUser);
       expect(mockPrismaService.user.update).toHaveBeenCalledWith({
@@ -186,7 +219,11 @@ describe('UsersController', () => {
       mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
       mockPrismaService.user.update.mockResolvedValue(updatedUser);
 
-      const result = await controller.update(mockUserId, updateDto, mockAuthenticatedStudentRequest);
+      const result = await controller.update(
+        mockUserId,
+        updateDto,
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual(updatedUser);
       expect(mockPrismaService.user.update).toHaveBeenCalledWith({
@@ -195,29 +232,47 @@ describe('UsersController', () => {
       });
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
+    it('should throw BadRequestException for invalid ID', async () => {
       await expect(
-        controller.update("invalid-id", updateDto, mockAuthenticatedAdminRequest),
+        controller.update(
+          'invalid-id',
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
       ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw BadRequestException for invalid data", async () => {
-      const invalidDto = { email: "invalid-email" };
+    it('should throw BadRequestException for invalid data', async () => {
+      const invalidDto = { email: 'invalid-email' };
 
       await expect(
-        controller.update(mockUserId, invalidDto, mockAuthenticatedAdminRequest),
+        controller.update(
+          mockUserId,
+          invalidDto,
+          mockAuthenticatedAdminRequest,
+        ),
       ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw NotFoundException when user not found", async () => {
+    it('should throw NotFoundException when user not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(null);
 
-      await expect(controller.update(randomUUID(), updateDto, mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.update(
+          randomUUID(),
+          updateDto,
+          mockAuthenticatedAdminRequest,
+        ),
+      ).rejects.toThrow(NotFoundException);
     });
 
-    it("should throw ForbiddenException for STUDENT updating other user", async () => {
+    it('should throw ForbiddenException for STUDENT updating other user', async () => {
       await expect(
-        controller.update(mockAdminId, updateDto, mockAuthenticatedStudentRequest),
+        controller.update(
+          mockAdminId,
+          updateDto,
+          mockAuthenticatedStudentRequest,
+        ),
       ).rejects.toThrow(ForbiddenException);
     });
   });
@@ -227,34 +282,50 @@ describe('UsersController', () => {
       mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
       mockPrismaService.user.delete.mockResolvedValue(mockUser);
 
-      const result = await controller.remove(mockUserId, mockAuthenticatedAdminRequest);
+      const result = await controller.remove(
+        mockUserId,
+        mockAuthenticatedAdminRequest,
+      );
 
       expect(result).toEqual({ message: 'Usuário deletado com sucesso.' });
-      expect(mockPrismaService.user.delete).toHaveBeenCalledWith({ where: { id: mockUserId } });
+      expect(mockPrismaService.user.delete).toHaveBeenCalledWith({
+        where: { id: mockUserId },
+      });
     });
 
     it('should delete own account for STUDENT', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
       mockPrismaService.user.delete.mockResolvedValue(mockUser);
 
-      const result = await controller.remove(mockUserId, mockAuthenticatedStudentRequest);
+      const result = await controller.remove(
+        mockUserId,
+        mockAuthenticatedStudentRequest,
+      );
 
       expect(result).toEqual({ message: 'Usuário deletado com sucesso.' });
-      expect(mockPrismaService.user.delete).toHaveBeenCalledWith({ where: { id: mockUserId } });
+      expect(mockPrismaService.user.delete).toHaveBeenCalledWith({
+        where: { id: mockUserId },
+      });
     });
 
-    it("should throw BadRequestException for invalid ID", async () => {
-      await expect(controller.remove("invalid-id", mockAuthenticatedAdminRequest)).rejects.toThrow(BadRequestException);
+    it('should throw BadRequestException for invalid ID', async () => {
+      await expect(
+        controller.remove('invalid-id', mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(BadRequestException);
     });
 
-    it("should throw NotFoundException when user not found", async () => {
+    it('should throw NotFoundException when user not found', async () => {
       mockPrismaService.user.findUnique.mockResolvedValue(null);
 
-      await expect(controller.remove(randomUUID(), mockAuthenticatedAdminRequest)).rejects.toThrow(NotFoundException);
+      await expect(
+        controller.remove(randomUUID(), mockAuthenticatedAdminRequest),
+      ).rejects.toThrow(NotFoundException);
     });
 
-    it("should throw ForbiddenException for STUDENT deleting other user", async () => {
-      await expect(controller.remove(mockAdminId, mockAuthenticatedStudentRequest)).rejects.toThrow(ForbiddenException);
+    it('should throw ForbiddenException for STUDENT deleting other user', async () => {
+      await expect(
+        controller.remove(mockAdminId, mockAuthenticatedStudentRequest),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 });
diff --git a/tsconfig.json b/tsconfig.json
index f668e37..5f7cc60 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,6 +1,7 @@
 {
   "compilerOptions": {
     "module": "commonjs",
+    "strict": true,
     "declaration": true,
     "removeComments": true,
     "emitDecoratorMetadata": true,
